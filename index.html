<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <link rel="stylesheet" href="css/cg.css">
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>
<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">Carrega aqui para comecar!</span>
        <br />
        (W, A, S, D = Mover, RATO = Olhar em volta, ESC = Retornar ao menu)
        <br />
        Pedro Roldan 21501217- Leandro Moreira 21601599 ISMAT 2017
    </div>
</div>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/PointerLockControls.js"></script>

<script>
    var myCanvas = document.getElementById('myCanvas');

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        MOVEMENT_SPEED = 4000;    //movement speed

    var scene, renderer, camera, controls, material;

    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var updateCam = 0;  //variavel para atualizar a camera, so passa a 1 apos o primeiro movimentos

    var blocker = document.getElementById( 'blocker' ); //chama o blocker, para ativacao do utilizador e comecar o lock
    var instructions = document.getElementById( 'instructions' );   //janela de instrucoes

    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    class Obj{
        constructor(){}
    }

    class Wood extends Obj{
        constructor(position){
            super();

            var loader = new THREE.ObjectLoader();
            loader.load("models/fire-wood.json", function ( obj ) {
                obj.position.x = position.x;
                obj.position.y = position.y;
                obj.position.z = position.z;
                scene.add( obj );
            });
        }

        getMesh(){
            return this.mesh;
        }
    }


    class Tree extends Obj{
        constructor(position){
            super();

            var loader = new THREE.ObjectLoader();
            loader.load("models/coconut-tree.json", function ( obj ) {
                obj.position.x = position.x;
                obj.position.y = position.y;
                obj.position.z = position.z;
                scene.add( obj );
            });
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Totem extends Obj{
        constructor(size,position){
            super();

            var sph = new THREE.Mesh(
                new THREE.SphereGeometry(25, 16, 16),
                new THREE.MeshBasicMaterial({color: 0xff00ff})
            );
            sph.position.x = position.x;
            sph.position.y = position.y + 250;
            sph.position.z = position.z;


            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            var woodTexture = THREE.ImageUtils.loadTexture('images/wood-texture.jpg'); //new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
            this.material = new THREE.MeshBasicMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;

            this.mesh.add(sph);
        }

        update(){
            //this.mesh.rotation.x += 0.1;
            //this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshBasicMaterial();

            this.material.map = THREE.ImageUtils.loadTexture('images/terrain2.jpg');            // Diffuse Texture
//            this.material.bumpMap = THREE.ImageUtils.loadTexture('images/earthmap4k.jpg');       // Bump Texture
//            this.material.bumpScale = 0.05;
//            this.material.specularMap = THREE.ImageUtils.loadTexture('images/earthspec4k.jpg');   // Spectacular Texture
//            this.material.specular = new THREE.Color('grey');

            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;
        }


        getMesh(){
            return this.mesh;
        }
    }

    class Aplication{

        /**
         * Metodo construtor
         */
        constructor() {
            this.objects = [];

            this.checkCompatibility(); //verifica a compatibilidade do PointerLockControls com o browser

            this.createScene();
        }

        /**
         * Metodo que cria a cena da aplicação
         */
        createScene() {
            //SCENE
            scene = new THREE.Scene();
            //scene.fog = new THREE.Fog(0xCCCFBC, 0.1, 2000);

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.y = 180;
            //camera.lookAt(scene.position);

            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL
            controls = new THREE.PointerLockControls( camera );
            scene.add( controls.getObject() );

            //LIGHTS
            var light = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(light);

            this.createSkyBox();

            //KEY LISTENERS
            document.addEventListener( 'keydown', this.onKeyDown, false );      //Listener da tecla ativada
            document.addEventListener( 'keyup', this.onKeyUp, false );          //listener para desativar as teclas
            window.addEventListener( 'resize', this.onWindowResize, false );    //listener para o resize

            this.render();

        }


        /**
         * Metodo que controla o evento KeyUp do teclado
         */
        onKeyUp ( event ) {
            switch( event.keyCode ) {
                case 87: // w
                    moveForward = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
        };

        /**
         * Metodo que controla o evento KeyDown do teclado
         */
        onKeyDown ( event ) {
            switch ( event.keyCode ) {
                case 87: // w
                    moveForward = true;
                    break;
                case 65: // a
                    moveLeft = true;
                    break;
                case 83: // s
                    moveBackward = true;
                    break;
                case 68: // d
                    moveRight = true;
                    break;
            }
        };

        /**
         * Metodo que verifica compatibilidade do browser
         */
        checkCompatibility () {
            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;
                        controls.enabled = true;
                        blocker.style.display = 'none';
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        instructions.style.display = '';
                    }
                };


                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    element.requestPointerLock();
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

        }

        /**
         * Metodo que controla o evento Window Resize do browse
         */
        onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.updateProjectionMatrix();
        }

        /**
         * Metodo que efetua o render da cena
         */
        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            if ( controlsEnabled ) { //Aplica o movimento com o WASD
                var time = performance.now();
                var delta = ( time - prevTime ) / 1000;
                var velocidadeMin = 5;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                if ( moveForward ) {
                    velocity.z -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveBackward ) {
                    velocity.z += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveLeft ) {
                    velocity.x -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveRight ) {
                    velocity.x += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                controls.getObject().translateX( velocity.x * delta );
                controls.getObject().translateZ( velocity.z * delta );

                if (velocity.z < velocidadeMin && velocity.z > -velocidadeMin && velocity.x < velocidadeMin && velocity.x > -velocidadeMin) {

                    if (updateCam === 1) {
                        controls.updatePosition();  //atualiza a camera com a variacao de 50 graus para todos os lados
                        updateCam=0;
                    }
                }

                prevTime = time;
            }

            //controls.update( clock.getDelta() );
            renderer.render(scene, camera);
        }

        /**
         * Metodo que adiciona mesh a partir de uma lista de objectos
         */
        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

        createSkyBox() {
            // SKYBOX
            var geometry2  = new THREE.SphereGeometry(6000, 200, 200);
            var material2  = new THREE.MeshBasicMaterial({
                map   : new THREE.ImageUtils.loadTexture('images/sky.jpg'),
                side  : THREE.BackSide
            });

            var skyBoxMesh  = new THREE.Mesh(geometry2, material2); // cria mesh com geometria e material
            scene.add(skyBoxMesh);
        }

    }

    let app = new Aplication(); // instancia nova aplicação

    /**
     * Lista de objectos da cena
     * @type {[*]}
     */
    let objs = [
        new Floor({width: 8000, height: 8000},{x:500,y:-1.8,z:-500}),
        new Totem({width: 40, height: 550, depth:10},{x:5,y:4,z:-2}),
        new Tree({x:-500,y:0,z:-200}),new Tree({x:-1000,y:0,z:-800}),
        new Tree({x:-700,y:0,z:-400}),new Tree({x:-1800,y:0,z:-300}),
        new Tree({x:-100,y:0,z:-200}),new Tree({x:-2000,y:0,z:-800}),
        new Tree({x:-200,y:0,z:-100}),new Tree({x:-3800,y:0,z:-500}),
        new Tree({x:-900,y:0,z:-280}),new Tree({x:-200,y:0,z:-780}),
        new Wood({x:40,y:100,z:10}),new Wood({x:100,y:120,z:10}),
        new Wood({x:55,y:555,z:10}),new Wood({x:80,y:200,z:10}),
        new Wood({x:440,y:220,z:10}),new Wood({x:450,y:850,z:10}),
        new Wood({x:648,y:350,z:10}),new Wood({x:980,y:880,z:10}),
        new Wood({x:400,y:380,z:10}),new Wood({x:780,y:655,z:10}),
    ];

    /**
     * Metodo que adiciona a lista de objectos a cena
     */
    app.add(objs);

</script>
</body>
</html>