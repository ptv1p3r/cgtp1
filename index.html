<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <link rel="stylesheet" href="css/cg.css">
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>
<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">Carrega aqui para comecar!!!! (TEMP SHIT)</span>
        <br />
        (W, A, S, D = Move, MOUSE = Look around, ESC = Return to menu)
    </div>
</div>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/PointerLockControls.js"></script>

<script>
    var myCanvas = document.getElementById('myCanvas');

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        DISTANCIA_MAX = 1000,
        DISTANCIA_MIN = 0,
        MOVEMENT_SPEED = 4000;    //movement speed

    var scene, renderer, camera, controls, material;


    // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
    // https://github.com/mrdoob/three.js/blob/master/examples/misc_controls_pointerlock.html

    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;

    var blocker = document.getElementById( 'blocker' ); //chama o blocker, para ativacao do utilizador e comecar o lock
    var instructions = document.getElementById( 'instructions' );   //janela de instrucoes

    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    class Obj{
        constructor(){}
    }

    class Tree extends Obj{
        constructor(position){
            super();

            var loader = new THREE.ObjectLoader();
            loader.load("models/coconut-tree.json", function ( obj ) {
                obj.position.x = position.x;
                obj.position.y = position.y;
                obj.position.z = position.z;
                scene.add( obj );
            });
        }

        update(){
//            this.mesh.rotation.x += 0.1;
//            this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Cube extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            this.material = new THREE.MeshBasicMaterial();
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
        }

        update(){
            //this.mesh.rotation.x += 0.1;
            //this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshBasicMaterial();

            this.material.map = THREE.ImageUtils.loadTexture('images/terrain1.jpg');            // Diffuse Texture
//            this.material.bumpMap = THREE.ImageUtils.loadTexture('images/earthmap4k.jpg');       // Bump Texture
//            this.material.bumpScale = 0.05;
//            this.material.specularMap = THREE.ImageUtils.loadTexture('images/earthspec4k.jpg');   // Spectacular Texture
//            this.material.specular = new THREE.Color('grey');

            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;
        }


        getMesh(){
            return this.mesh;
        }
    }

    class Aplication{
        constructor() {
            this.objects = [];

            this.createScene();
        }

        createScene() {
            //SCENE
            scene = new THREE.Scene();

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.y = 180;
            //camera.lookAt(scene.position);

            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL
            controls = new THREE.PointerLockControls( camera );
            scene.add( controls.getObject() );

            //KEY LISTENERS
            document.addEventListener( 'keydown', this.onKeyDown, false );   //Listener da tecla ativada
            document.addEventListener( 'keyup', this.onKeyUp, false );   //listener para desativar as teclas


            //LIGHTS
            var light = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(light);

            window.addEventListener( 'resize', this.onWindowResize, false );

            this.checkCompatibility(); //verifica a compatibilidade do PointerLockControls com o browser
            animate();
            this.render();

        }

        onKeyUp ( event ) {
            switch( event.keyCode ) {

                case 87: // w
                    moveForward = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
        };

        onKeyDown ( event ) {
            switch ( event.keyCode ) {

                case 87: // w
                    moveForward = true;
                    break;
                case 65: // a
                    moveLeft = true;
                    break;
                case 83: // s
                    moveBackward = true;
                    break;
                case 68: // d
                    moveRight = true;
                    break;
            }
        };

        checkCompatibility () {

            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;
                        controls.enabled = true;
                        blocker.style.display = 'none';
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        instructions.style.display = '';
                    }
                };


                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    element.requestPointerLock();
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

        }

        onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            //this.render();
        }

        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            //controls.update( clock.getDelta() );
            renderer.render(scene, camera);
        }

        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

    }

    //Aplica o movimento com o WASD
    function animate() {
        requestAnimationFrame( animate );

        if ( controlsEnabled ) {

            var time = performance.now();
            var delta = ( time - prevTime ) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            if ( moveForward ) {
                velocity.z -= MOVEMENT_SPEED * delta;
            }

            if ( moveBackward ) {
                velocity.z += MOVEMENT_SPEED * delta;
            }

            if ( moveLeft ) {
                velocity.x -= MOVEMENT_SPEED * delta;
            }

            if ( moveRight ) {
                velocity.x += MOVEMENT_SPEED * delta;
            }

            controls.getObject().translateX( velocity.x * delta );
            controls.getObject().translateZ( velocity.z * delta );

            prevTime = time;
        }

        renderer.render( scene, camera );
    }

    let app = new Aplication();

    let objs = [
        new Floor({width: 5000, height: 5000},{x:500,y:-1.8,z:-500}),
        new Cube({width: 4, height: 5, depth:10},{x:5,y:4,z:-2}),
        new Tree({x:-500,y:0,z:-200}),
        new Tree({x:-1000,y:0,z:-800})
    ];
    app.add(objs);

</script>
</body>
</html>