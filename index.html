<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <link rel="stylesheet" href="css/cg.css">
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>
<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">Carrega aqui para comecar!</span>
        <br />
        (W, A, S, D = Mover, RATO = Olhar em volta, ESC = Retornar ao menu)
        <br />
        Pedro Roldan 21501217- Leandro Moreira 21601599 ISMAT 2017
    </div>
</div>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/MTLLoader.js"></script>

<script>
    var myCanvas = document.getElementById('myCanvas');
    var blocker = document.getElementById( 'blocker' );             //chama o blocker, para ativacao do utilizador e comecar o lock
    var instructions = document.getElementById( 'instructions' );   //janela de instrucoes

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        MOVEMENT_SPEED = 4000;    //movement speed

    var scene, renderer, camera, controls, material;

    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var updateCam = 1;  //variavel para atualizar a camera, so passa a 1 apos o primeiro movimentos
    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    var sound = null;

    class Obj{
        constructor(){}
    }

    class RockStack extends Obj{
        constructor(position, stackColor){
            super();

            var materialPath;

            switch (stackColor) {

                case 1:
                    materialPath = "images/rock1.jpg";
                    break;

                case 2:
                    materialPath = "images/rock2.jpg";
                    break;

                case 3:
                    materialPath = "images/rock3.jpg";
                    break;

                case 4:
                    materialPath = "images/rock4.jpg";
                    break;


            }

            var material = new THREE.MeshLambertMaterial();
            material.map = new THREE.ImageUtils.loadTexture(materialPath);

            var objLoader = new THREE.OBJLoader();
            objLoader.load( "models/blender_rocks.obj", function (object) {
                object.scale.set( 50, 50, 50);
                object.position.x = position.x;
                object.position.y = position.y;
                object.position.z = position.z;

                object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.castShadow = true;
                        child.material = material;
                    }
                });

                scene.add( object );

            });
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Rocks extends Obj{
        constructor(position){
            super();

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/Rock1.mtl", function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/Rock1.obj", function (object) {
                    object.scale.set( 50, 50, 50);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    class Tree extends Obj{
        constructor(position, treeType){
            super();

            var mtlPath, objPath;

            switch (treeType) {

                case 1:
                    mtlPath = "models/DeadTree1.mtl";
                    objPath = "models/DeadTree1.obj";
                    break;

                case 2: //mini 1
                    mtlPath = "models/DeadTree2.mtl";
                    objPath = "models/DeadTree2.obj";
                    break;

                case 3:
                    mtlPath = "models/DeadTree3.mtl";
                    objPath = "models/DeadTree3.obj";
                    break;

                case 4: //mini 3
                    mtlPath = "models/DeadTree4.mtl";
                    objPath = "models/DeadTree4.obj";
                    break;


            }

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( mtlPath , function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( objPath, function (object) {

                    if (treeType === 4){
                        object.scale.set(0.5, 0.5, 0.5);
                    } else {
                        object.scale.set(1, 1, 1);
                    }

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    scene.add( object );
                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    class InformationPlate extends Obj{
        constructor(size,position){
            super();

            var sph = new THREE.Mesh(
                new THREE.SphereGeometry(25, 16, 16),
                new THREE.MeshLambertMaterial({color: 0xff00ff})
            );
            sph.position.x = position.x;
            sph.position.y = position.y + 250;
            sph.position.z = position.z;


            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            var woodTexture = THREE.ImageUtils.loadTexture('images/wood-texture.jpg'); //new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
            this.material = new THREE.MeshLambertMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;

            this.mesh.rotation.y = Math.PI / 2; //tabua de frente para o utilizador

            this.mesh.add(sph);

            this.mesh.castShadow = true;
            this.mesh.receiveShadow = false;

        }

        getMesh(){
            return this.mesh;
        }
    }

    class Path extends Obj {
        constructor(position, type, rotation) {
            super();
            this.geometry = new THREE.PlaneGeometry(512, 256);
            this.material = new THREE.MeshLambertMaterial();

            switch (type) {
                case 1: //Direito
                    this.material.map = THREE.ImageUtils.loadTexture("images/dirt_road.jpg");
                    break;

                case 2: //T
                    this.material.map = THREE.ImageUtils.loadTexture("images/dirt_road_T.jpg");
                    break;
            }


            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI / 2;

            switch (rotation) {
                case 1: //Vertical
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI; //messed up a texture, TODO: fix that shit
                    break;

                case 2: //Horizontal
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 2;
                    break;
            }

            this.mesh.receiveShadow = true;

        }

        getMesh() {
            return this.mesh;
        }
    }

    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshLambertMaterial();

            this.material.map = THREE.ImageUtils.loadTexture('images/floor.jpg');
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;

            this.mesh.castShadow = true;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Aplication{

        /**
         * Metodo construtor
         */
        constructor() {
            this.objects = [];

            this.checkCompatibility(); //verifica a compatibilidade do PointerLockControls com o browser

            this.createScene();
        }

        /**
         * Metodo que cria a cena da aplicação
         */
        createScene() {
            //SCENE
            scene = new THREE.Scene();

            //scene.fog = new THREE.Fog(0xd5c7e8, 0.5, 2000);
            //scene.fog = new THREE.Fog(0xCCCFBC, 0.5, 2000); //a usar


            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.y = 180;


            //Cria AudioListener e adiciona a camera
            var listener = new THREE.AudioListener();
            camera.add( listener );

            // Cria um audio source global
            sound = new THREE.Audio( listener );
            var audioLoader = new THREE.AudioLoader();

            //Carrega o som e set o buffer de audio
            audioLoader.load( 'sounds/348997_klankbeeld_horror-ambience-160531-0886.ogg', function( buffer ) {
                sound.setBuffer( buffer );
                sound.setLoop(true);
                sound.setVolume(0.5);
                //sound.play();
            });

            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;
            renderer.shadowCameraNear = 3;
            renderer.shadowCameraFar = camera.far;
            renderer.shadowCameraFov = 50;
            renderer.shadowMapBias = 0.0039;
            renderer.shadowMapDarkness = 0.5;
            renderer.shadowMapWidth = 1024;
            renderer.shadowMapHeight = 1024;
            // to antialias the shadow
            renderer.shadowMapType = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL
            controls = new THREE.PointerLockControls( camera );
            controls.getObject().rotation.y = Math.PI/2;
            controls.getObject().position.set( 4000, 0, 0);
            scene.add( controls.getObject() );

            //LIGHTS
            var ambientlight = new THREE.AmbientLight(0xffffff);
            ambientlight.intensity = 1;
            scene.add(ambientlight);

//            var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
//           // directionalLight.position.set(100, 100, 50);
//            directionalLight.position.set( -60, 20, 100 );
//            directionalLight.castShadow = true;
//            directionalLight.shadowDarkness = 0.2;
//            directionalLight.shadowCameraVisible = true;
//            directionalLight.shadowMapWidth = 2048;
//            directionalLight.shadowMapHeight = 2048;
//            directionalLight.shadowCameraNear = 100;
//            directionalLight.shadowCameraFar = 2048;
//            directionalLight.shadowCameraFov = 30;

//  .          scene.add( directionalLight );

            var spotLight = new THREE.SpotLight( 0xffffff );
            spotLight.position.set( 1700, 1000, 100 );
            //spotLight.position.copy( camera.position );
            spotLight.intensity = 0.5;

            spotLight.castShadow = true;
            spotLight.shadowCameraVisible = true;

            spotLight.shadowMapWidth = 2048;
            spotLight.shadowMapHeight = 2048;

            spotLight.shadowCameraNear = 100;
            spotLight.shadowCameraFar = 2048;
            spotLight.shadowCameraFov = 30;

            scene.add( spotLight );


            this.createSkyBox();

            //KEY LISTENERS
            document.addEventListener( 'keydown', this.onKeyDown, false );      //Listener da tecla ativada
            document.addEventListener( 'keyup', this.onKeyUp, false );          //listener para desativar as teclas
            window.addEventListener( 'resize', this.onWindowResize, false );    //listener para o resize

            this.render();

        }


        /**
         * Metodo que controla o evento KeyUp do teclado
         */
        onKeyUp ( event ) {
            switch( event.keyCode ) {
                case 87: // w
                    moveForward = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
        };

        /**
         * Metodo que controla o evento KeyDown do teclado
         */
        onKeyDown ( event ) {
            switch ( event.keyCode ) {
                case 87: // w
                    moveForward = true;
                    break;
                case 65: // a
                    moveLeft = true;
                    break;
                case 83: // s
                    moveBackward = true;
                    break;
                case 68: // d
                    moveRight = true;
                    break;
                case 27: // esc
                    sound.stop();
                    break;

            }
        };

        /**
         * Metodo que verifica compatibilidade do browser
         */
        checkCompatibility () {
            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;
                        controls.enabled = true;
                        blocker.style.display = 'none';
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        instructions.style.display = '';
                    }
                };


                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    element.requestPointerLock();
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

        }

        /**
         * Metodo que controla o evento Window Resize do browse
         */
        onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.updateProjectionMatrix();
        }

        /**
         * Metodo que efetua o render da cena
         */
        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            if ( controlsEnabled ) { //Aplica o movimento com o WASD
                var time = performance.now();
                var delta = ( time - prevTime ) / 1000;
                var velocidadeMin = 10;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                if ( moveForward ) {
                    velocity.z -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveBackward ) {
                    velocity.z += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveLeft ) {
                    velocity.x -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveRight ) {
                    velocity.x += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                controls.getObject().translateX( velocity.x * delta );
                controls.getObject().translateZ( velocity.z * delta );

                if (velocity.z < velocidadeMin && velocity.z > -velocidadeMin && velocity.x < velocidadeMin && velocity.x > -velocidadeMin) {

                    if (updateCam === 1) {
                        controls.updatePosition();  //atualiza a camera com a variacao de 50 graus para todos os lados
                        updateCam=0;
                    }
                }

                prevTime = time;
            }

            //controls.update( clock.getDelta() );
            renderer.render(scene, camera);
        }

        /**
         * Metodo que adiciona mesh a partir de uma lista de objectos
         */
        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

        createSkyBox() {

            var urls = [
                "images/nightsky_rt.jpg", "images/nightsky_lf.jpg",
                "images/nightsky_up.jpg", "images/nightsky_dn.jpg",
                 "images/nightsky_bk.jpg", "images/nightsky_ft.jpg"];

            var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
            cubemap.format = THREE.RGBFormat;

            var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
            shader.uniforms['tCube'].value = cubemap; // apply textures to shader

            // create shader material
            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: shader.fragmentShader,
                vertexShader: shader.vertexShader,
                uniforms: shader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });


            // create skybox mesh
            var skyboxSize = 8000;

            var skybox = new THREE.Mesh(
                new THREE.CubeGeometry(skyboxSize, skyboxSize, skyboxSize),
                skyBoxMaterial
            );

            skybox.position.x = 500;
            skybox.position.y = 0;
            skybox.position.z = -500;

            scene.add(skybox);

//            // SKYBOX
//            var geometry2  = new THREE.SphereGeometry(6000, 200, 200);
//            var material2  = new THREE.MeshBasicMaterial({
//                map   : new THREE.ImageUtils.loadTexture('images/dark_sky.jpg'),
//                side  : THREE.BackSide
//            });
//
//            var skyBoxMesh  = new THREE.Mesh(geometry2, material2); // cria mesh com geometria e material
//            scene.add(skyBoxMesh);
        }

    }

    let app = new Aplication(); // instancia nova aplicação

    /**
     * Lista de objectos da cena
     * @type {[*]}
     */
    let objs = [
        new Floor({width: 8000, height: 8000},{x:500,y:-1.8,z:-500}),
        new InformationPlate({width: 40, height: 550, depth:10},{x:-1400,y:0,z:10}),
        new Tree({x:300,y:0,z:-200}, 1),new Tree({x:300,y:0,z:200}, 1),
        new Tree({x:1000,y:0,z:-200}, 2),new Tree({x:1000,y:0,z:200}, 2),
        new Tree({x:2000,y:0,z:-200}, 3),new Tree({x:2000,y:0,z:200}, 3),
        new Tree({x:3000,y:0,z:-200}, 2),new Tree({x:3000,y:0,z:200}, 4),
        new Tree({x:4000,y:0,z:-200}, 1),new Tree({x:3700,y:0,z:325}, 2),
        new Tree({x:2652,y:0,z:-1355}, 3),new Tree({x:2500,y:0,z:1250}, 3),
        new Tree({x:1500,y:0,z:-985}, 3),new Tree({x:1500,y:0,z:1125}, 3),
        new Tree({x:800,y:0,z:-900}, 3),new Tree({x:800,y:0,z:500}, 3),
        new Tree({x:200,y:0,z:-985}, 3),new Tree({x:200,y:0,z:725}, 3),
        new Tree({x:-200,y:0,z:-200}, 3),new Tree({x:-200,y:0,z:200}, 3),
        new RockStack({x:55,y:0,z:-1778}, 2),new RockStack({x:1000,y:0,z:1000}, 3),
        new RockStack({x:2000,y:0,z:-2455}, 3),new RockStack({x:3000,y:0,z:2856}, 4),

        new Path({x:149,y:0,z:10}, 1, 1),new Path({x:661,y:0,z:10}, 1, 1),
        new Path({x:1173,y:0,z:10}, 1, 1),new Path({x:1685,y:0,z:10}, 1, 1),
        new Path({x:2197,y:0,z:10}, 1, 1),new Path({x:2709,y:0,z:10}, 1, 1),
        new Path({x:3221,y:0,z:10}, 1, 1),new Path({x:3733,y:0,z:10}, 1, 1),
        new Path({x:4245,y:0,z:10}, 1, 1),
        new Tree({x:-600,y:0,z:-200}, 1),new Tree({x:-600,y:0,z:200}, 2),
        new Path({x:-363,y:0,z:10}, 1, 1),new Path({x:-875,y:0,z:10},1 ,1),
        new Path({x:-1259,y:0,z:10}, 2, 2),//new Path({x:-1500,y:0,z:-600}),
        // Desvio
        new Path({x:-1500,y:0,z:600}, 2),
        new Tree({x:-1500,y:0,z:10}, 3),
        // cemiterio
        new Path({x:-2000,y:0,z:900}, 2),new Rocks({x:-2000,y:0,z:1200}),
        new Tree({x:-2500,y:0,z:1250}, 3),new Tree({x:-1500,y:0,z:1250}, 3),
        new Tree({x:-1000,y:0,z:500}, 1),new Tree({x:-1900,y:0,z:500}, 1),
        new RockStack({x:-2500,y:0,z:-500},1),new RockStack({x:-2500,y:0,z:2000},1),
        // casa
        new Rocks({x:-2000,y:0,z:-1200}),new Tree({x:-2500,y:0,z:-1250},3),
        new Tree({x:-1500,y:0,z:-1250}, 1),new Tree({x:-1000,y:0,z:-500}, 1),

    ];

    /**
     * Metodo que adiciona a lista de objectos a cena
     */
    app.add(objs);

</script>
</body>
</html>