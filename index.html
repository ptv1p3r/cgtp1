<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <link rel="stylesheet" href="css/cg.css">
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>
<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">Carrega aqui para comecar!</span>
        <br />
        (W, A, S, D = Mover, RATO = Olhar em volta, ESC = Retornar ao menu, Som tem de estar ligado)
        <br />
        Pedro Roldan 21501217- Leandro Moreira 21601599 ISMAT 2017
    </div>
</div>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/MTLLoader.js"></script>

<script>
    var myCanvas = document.getElementById('myCanvas');
    var blocker = document.getElementById( 'blocker' );             //chama o blocker, para ativacao do utilizador e comecar o lock
    var instructions = document.getElementById( 'instructions' );   //janela de instrucoes

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        MOVEMENT_SPEED = 3000,
        SHADOWMAPWIDTH = 2048,
        SHADOWMAPHEIGHT = 2048;//movement speed

    var scene, renderer, camera, controls;

    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var updateCam = 1;  //variavel para atualizar a camera, so passa a 1 apos o primeiro movimentos
    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    var sound = null;

    class Obj{
        constructor(){}
    }

    /**
     * Metodo construtor do modelo de monte de rochas
     */
    class RockStack extends Obj{
        constructor(position, stackColor){
            super();

            var materialPath;

            // tipo de rochas
            switch (stackColor) {

                case 1:
                    materialPath = "images/rock1.jpg";
                    break;

                case 2:
                    materialPath = "images/rock2.jpg";
                    break;

                case 3:
                    materialPath = "images/rock3.jpg";
                    break;

                case 4:
                    materialPath = "images/rock4.jpg";
                    break;


            }

            // carrega o material escolhido
            var material = new THREE.MeshPhongMaterial();
            material.map = new THREE.ImageUtils.loadTexture(materialPath);

            //carrega o modelo
            var objLoader = new THREE.OBJLoader();
            objLoader.load( "models/blender_rocks.obj", function (object) {
                object.scale.set( 25, 25, 25);
                object.position.x = position.x;
                object.position.y = position.y;
                object.position.z = position.z;

                //ativa as sombras
                object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.castShadow = true;
                        child.material = material;
                    }
                });

                //adiciona o modelo
                scene.add( object );

            });
        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor do modelo de uma rocha
     */
    class Rocks extends Obj{
        constructor(position){
            super();

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/Rock1.mtl", function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/Rock1.obj", function (object) {
                    object.scale.set( 50, 50, 50);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor dos modelos das arvores
     */
    class Tree extends Obj{
        constructor(position, treeType){
            super();

            var mtlPath, objPath;

            //verifica modelo da arvore
            switch (treeType) {

                case 1:
                    mtlPath = "models/DeadTree1.mtl";
                    objPath = "models/DeadTree1.obj";
                    break;

                case 2: //mini 1
                    mtlPath = "models/DeadTree2.mtl";
                    objPath = "models/DeadTree2.obj";
                    break;

                case 3:
                    mtlPath = "models/DeadTree3.mtl";
                    objPath = "models/DeadTree3.obj";
                    break;

                case 4: //mini 3
                    mtlPath = "models/DeadTree4.mtl";
                    objPath = "models/DeadTree4.obj";
                    break;


            }

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( mtlPath , function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( objPath, function (object) {

                    //escala dos modelos
                    if (treeType === 4){
                        object.scale.set(0.5, 0.5, 0.5);
                    } else {
                        object.scale.set(1, 1, 1);
                    }

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;
                    object.side = THREE.BackSide;

                    scene.add( object );
                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Motodo construtor para o sinal de informacao
     */
    class InformationPlate extends Obj{
        constructor(size,position){
            super();

            //tabua principal
            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            var woodTexture = THREE.ImageUtils.loadTexture('images/wood-texture.jpg'); //new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
            this.material = new THREE.MeshPhongMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;

            //------ Grave -----//

            //tabua do grave
            this.geometry = new THREE.BoxGeometry(20, 100, 5);
            this.gravePointer = new THREE.Mesh(this.geometry, this.material);
            this.gravePointer.position.x = -50;
            this.gravePointer.position.y = 240;
            this.gravePointer.position.z = 6.5;

            this.gravePointer.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.castShadow = true;
                }
            });

            this.gravePointer.rotation.z = Math.PI / 2;

            //----- Parafusos -----//
            this.nailMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });

            this.radius = .5;
            this.segments = 32; //<-- Increase or decrease for more resolution I guess

            this.circleGeometry = new THREE.CircleGeometry( this.radius, this.segments );
            this.circle1 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );

            this.circle1.position.x = 5;
            this.circle1.position.y = -46;
            this.circle1.position.z = 2.6;
            this.gravePointer.add( this.circle1 );

            this.circle2 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle2.position.x = -5;
            this.circle2.position.y = -46;
            this.circle2.position.z = 2.6;
            this.gravePointer.add( this.circle2 );

            // definicao do texto na tabua
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            this.context.font = "Bold 15px Arial";
            this.context.fillStyle = "rgb(0,0,0)";
            this.context.fillText('GRAVEYARD', 0, 20);

            // texture
            this.texture = new THREE.Texture(this.canvas);
            this.texture.needsUpdate = true;

            // material
            this.material = new THREE.MeshPhongMaterial( {map: this.texture, side:THREE.DoubleSide } );
            this.material.transparent = true;

            // grave text mesh
            this.graveTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(this.canvas.width, this.canvas.height),
                this.material
            );

            // posicionar na tabua o texto
            this.graveTextMesh.position.set(-60,-102,2.6);
            this.graveTextMesh.rotation.z = -Math.PI / 2;

            this.gravePointer.add( this.graveTextMesh );

            this.mesh.add(this.gravePointer);

            //------ Mansion -----//

            // tabua da mansion
            this.geometry = new THREE.BoxGeometry(20, 100, 5);
            this.material = new THREE.MeshPhongMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mansionPointer = new THREE.Mesh(this.geometry, this.material);
            this.mansionPointer.position.x = 50;
            this.mansionPointer.position.y = 220;
            this.mansionPointer.position.z = 6.5;

            this.mansionPointer.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.castShadow = true;
                }
            });

            this.mansionPointer.rotation.z = Math.PI / 2;

            //----- Parafusos -----//

            this.circle3 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle3.position.x = -15;
            this.circle3.position.y = -54;
            this.circle3.position.z = 2.6;
            this.gravePointer.add( this.circle3 );

            this.circle4 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle4.position.x = -25;
            this.circle4.position.y = -54;
            this.circle4.position.z = 2.6;
            this.gravePointer.add( this.circle4 );

            // definicao do texto na tabua
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            this.context.font = "Bold 15px Arial";
            this.context.fillStyle = "rgb(0,0,0)";
            this.context.fillText('MANSION', 0, 20);

            // texture
            this.texture = new THREE.Texture(this.canvas);
            this.texture.needsUpdate = true;

            // material
            this.material = new THREE.MeshPhongMaterial( {map: this.texture, side:THREE.DoubleSide } );
            this.material.transparent = true;

            // mansion text mesh
            this.mansionTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(this.canvas.width, this.canvas.height),
                this.material
            );

            // posicionar na tabua o texto
            this.mansionTextMesh.position.set(-60,-120,2.61);
            this.mansionTextMesh.rotation.z = -Math.PI / 2;

            this.mansionPointer.add(this.mansionTextMesh );

            this.mesh.add(this.mansionPointer);


            this.mesh.rotation.y = Math.PI / 2; //tabua de frente para o utilizador

            //ativa as sombras
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = false;

        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor do caminho
     */
    class Path extends Obj {
        constructor(position, rotation, type) {
            super();

            //tipo de caminho
            switch (type) {

                case 'S':   //direito
                    this.geometry = new THREE.PlaneGeometry(512, 256);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/dirt_road.jpg");
                    break;

                case 'Y':   //Y
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/Y_road.png");
                    this.material.transparent = true;
                    break;

                case 'L':   //esquerda
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/left_road.png");
                    this.material.transparent = true;
                    break;

                case 'R':   //direita
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/right_road.png");
                    this.material.transparent = true;
                    break;

            }

            //cria e posiciona a mesh
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;

            //rotacao da mesh, depende do path
            switch (rotation) {
                case 1: // Vertical
                    this.mesh.rotation.x = -Math.PI / 2;
                    break;

                case 2: // Y
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 2;
                    break;

                case 3: // /
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = -Math.PI / 4;
                    break;

                case 4: // \
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 4;
                    break;

                case 5: // / -> right
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 4;
                    break;

                case 6: // left <- \
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = -(5 * Math.PI / 4);
                    break;

            }

            this.mesh.receiveShadow = true;

        }

        getMesh() {
            return this.mesh;
        }
    }

    /**
     * Metodo construtor do chao da cena
     */
    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshPhongMaterial(); // lambert nao permite a correcta iluminacao

            this.material.map = THREE.ImageUtils.loadTexture('images/floor.jpg');
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;

            this.mesh.receiveShadow = true;
        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor de uma sepultura
     */
    class Grave extends Obj{
        constructor(position){
            super();

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/dirt_grave.mtl", function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/dirt_grave.obj", function (object) {
                    object.scale.set( 4, 4, 4);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    object.rotation.y = Math.PI / 2;

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor de uma casa
     */
    class House extends Obj{
        constructor(position){
            super();

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/casa.mtl", function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/casa.obj", function (object) {
                    object.scale.set( 13, 13, 13);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    object.rotation.y = -Math.PI/2;

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            })

        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor de um poste de luz
     */
    class LightPole extends Obj{
        constructor(position,rotation,lamp,pole){
            super();

            this.geometry = new THREE.CubeGeometry(100, 10, 10);
            this.material = new THREE.MeshPhongMaterial();
            this.material.map = THREE.ImageUtils.loadTexture('images/wood-texture.jpg');
            this.armMesh = new THREE.Mesh( this.geometry, this.material );

            this.armMesh .position.x = 10;
            this.armMesh .position.y = 180;
            this.armMesh .position.z = 0;
            this.armMesh .castShadow = true;

            this.geometry = new THREE.CubeGeometry(20, 40, 20);
            this.material = new THREE.MeshPhongMaterial({color: 0xfff500});
            //this.material.map = THREE.ImageUtils.loadTexture('images/wood-texture.jpg');
            this.lampMesh = new THREE.Mesh( this.geometry, this.material );

            this.lampMesh.position.x = 50;
            this.lampMesh.position.y = 155;
            this.lampMesh.position.z = 0;
            this.lampMesh.castShadow = true;

            this.geometry = new THREE.CylinderGeometry(10, 10, 350);
            this.material = new THREE.MeshPhongMaterial();
            this.material.map = THREE.ImageUtils.loadTexture('images/iron.jpg');
            this.poleMesh = new THREE.Mesh( this.geometry, this.material );

            this.poleMesh.position.x = position.x;
            this.poleMesh.position.y = position.y + 150;
            this.poleMesh.position.z = position.z;
            this.poleMesh.rotation.y = rotation.y;
            this.poleMesh.castShadow = true;

            this.poleMesh.add(this.armMesh);
            this.poleMesh.add(this.lampMesh);

            var poleLight = new THREE.SpotLight(0x1b150a);
            poleLight.position.set(this.lampMesh.position.x,this.lampMesh.position.y,this.lampMesh.position.z);
            poleLight.target = this.poleMesh;
            poleLight.castShadow = true;
            poleLight.intensity = pole.intensity;
            poleLight.angle = pole.angle;
            poleLight.penumbra = 0.1;
            poleLight.shadowCameraVisible = true;
            poleLight.shadowMapWidth = SHADOWMAPWIDTH;
            poleLight.shadowMapHeight = SHADOWMAPHEIGHT;

            poleLight.shadowCameraNear = 100;
            poleLight.shadowCameraFar = 2048;
            poleLight.shadowCameraFov = 30;

            this.poleMesh.add(poleLight);

            var lampLight = new THREE.SpotLight(0xffffff);
            lampLight.position.set(this.lampMesh.position.x,this.lampMesh.position.y-10,this.lampMesh.position.z);
            lampLight.target = this.lampMesh;
            lampLight.intensity = lamp.intensity;
            lampLight.angle = lamp.angle;
            lampLight.penumbra = 0.5;
            lampLight.castShadow = true;
            lampLight.shadowCameraVisible = true;
            lampLight.shadowMapWidth = SHADOWMAPWIDTH;
            lampLight.shadowMapHeight = SHADOWMAPHEIGHT;

            lampLight.shadowCameraNear = 100;
            lampLight.shadowCameraFar = 2048;
            lampLight.shadowCameraFov = 30;

            this.lampMesh.add(lampLight);
        }

        getMesh(){
            return this.poleMesh;
        }
    }

    /**
     * Metodo que inicializa a aplicacao
     */
    class Aplication{

        /**
         * Metodo construtor
         */
        constructor() {
            this.objects = [];

            this.checkCompatibility(); //verifica a compatibilidade do PointerLockControls com o browser

            this.createScene();
        }

        /**
         * Metodo que cria a cena da aplicação
         */
        createScene() {
            //SCENE
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog( 0x000000, .5, 2000 );

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.y = 180;

            //Cria AudioListener e adiciona a camera
            var listener = new THREE.AudioListener();
            camera.add( listener );

            // Cria um audio source global
            sound = new THREE.Audio( listener );
            var audioLoader = new THREE.AudioLoader();

            //Carrega o som e set o buffer de audio
            audioLoader.load( 'sounds/348997_klankbeeld_horror-ambience-160531-0886.ogg', function( buffer ) {
                sound.setBuffer( buffer );
                sound.setLoop(true);
                sound.setVolume(0.5);
                sound.play();
            });

            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;
            renderer.shadowCameraNear = 3;
            renderer.shadowCameraFar = camera.far;
            renderer.shadowCameraFov = 50;
            renderer.shadowMapBias = 0.0039;
            renderer.shadowMapDarkness = 0.5;
            renderer.shadowMapWidth = SHADOWMAPWIDTH;
            renderer.shadowMapHeight = SHADOWMAPHEIGHT;
            renderer.shadowMapType = THREE.PCFSoftShadowMap; // to antialias the shadow

            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL (As restricoes da camera foram efetuadas no PointerLockControls.js, linha 26)
            controls = new THREE.PointerLockControls( camera );
            controls.getObject().rotation.y = Math.PI/2;
            controls.getObject().position.set( 4000, 0, 0);
            scene.add( controls.getObject() );

            this.createSkyBox(); // cria skybox e iluminacao correspondente

            //KEY LISTENERS
            document.addEventListener( 'keydown', this.onKeyDown, false );      //Listener da tecla ativada
            document.addEventListener( 'keyup', this.onKeyUp, false );          //listener para desativar as teclas
            window.addEventListener( 'resize', this.onWindowResize, false );    //listener para o resize

            this.render();

        }


        /**
         * Metodo que controla o evento KeyUp do teclado
         */
        onKeyUp ( event ) {
            switch( event.keyCode ) {
                case 87: // w
                    moveForward = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
        };

        /**
         * Metodo que controla o evento KeyDown do teclado
         */
        onKeyDown ( event ) {
            switch ( event.keyCode ) {
                case 87: // w
                    moveForward = true;
                    break;
                case 65: // a
                    moveLeft = true;
                    break;
                case 83: // s
                    moveBackward = true;
                    break;
                case 68: // d
                    moveRight = true;
                    break;
                case 27: // esc
                    sound.stop();
                    break;

            }
        };

        /**
         * Metodo que verifica compatibilidade do browser
         */
        checkCompatibility () {
            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;
                        controls.enabled = true;
                        blocker.style.display = 'none';
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        instructions.style.display = '';
                    }
                };


                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    element.requestPointerLock();
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

        }

        /**
         * Metodo que controla o evento Window Resize do browse
         */
        onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.updateProjectionMatrix();
        }

        /**
         * Metodo que efetua o render da cena
         */
        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            if ( controlsEnabled ) { //Aplica o movimento com o WASD
                var time = performance.now();
                var delta = ( time - prevTime ) / 1000;
                var velocidadeMin = 10;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                if ( moveForward ) {
                    velocity.z -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveBackward ) {
                    velocity.z += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveLeft ) {
                    velocity.x -= MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                if ( moveRight ) {
                    velocity.x += MOVEMENT_SPEED * delta;
                    updateCam=1;    //confirma a existencia de um movimento
                }

                controls.getObject().translateX( velocity.x * delta );
                controls.getObject().translateZ( velocity.z * delta );

                if (velocity.z < velocidadeMin && velocity.z > -velocidadeMin && velocity.x < velocidadeMin && velocity.x > -velocidadeMin) {

                    if (updateCam === 1) {
                        controls.updatePosition();  //atualiza a camera com a variacao de 50 graus para todos os lados
                        updateCam=0;
                    }
                }

                prevTime = time;
            }

            //controls.update( clock.getDelta() );
            renderer.render(scene, camera);
        }

        /**
         * Metodo que adiciona mesh a partir de uma lista de objectos
         */
        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

        createSkyBox() {

            var urls = [
                "images/nightsky_rt.jpg", "images/nightsky_lf.jpg",
                "images/nightsky_up.jpg", "images/nightsky_dn.jpg",
                 "images/nightsky_bk.jpg", "images/nightsky_ft.jpg"];

            var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
            cubemap.format = THREE.RGBFormat;

            var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
            shader.uniforms['tCube'].value = cubemap; // apply textures to shader

            // shader material
            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: shader.fragmentShader,
                vertexShader: shader.vertexShader,
                uniforms: shader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });


            // skybox mesh
            var skyboxSize = 8000;

            var skybox = new THREE.Mesh(
                new THREE.CubeGeometry(skyboxSize, skyboxSize, skyboxSize),
                skyBoxMaterial
            );

            skybox.position.x = 500;
            skybox.position.y = 0;
            skybox.position.z = -500;

            var moonLight = new THREE.DirectionalLight(0xc8bcbc);
            moonLight.position.set( -4000, 4000, -4000 );
            moonLight.castShadow = true;
            moonLight.intensity = 0.1;
            moonLight.shadowDarkness = 0.5;
            moonLight.shadowCameraVisible = true;
            moonLight.shadowMapWidth = SHADOWMAPWIDTH;
            moonLight.shadowMapHeight = SHADOWMAPHEIGHT;
            moonLight.shadowCameraNear = 100;
            moonLight.shadowCameraFar = 2048;
            moonLight.shadowCameraFov = 30;
            skybox.add(moonLight);

            scene.add(skybox);
        }

    }

    let app = new Aplication(); // instancia nova aplicação

    /**
     * Lista de objectos da cena
     * @type {[*]}
     */
    let objs = [
        new Floor({width: 8000, height: 8000},{x:500,y:-1.8,z:-500}),
        new InformationPlate({width: 30, height: 550, depth:10},{x:-1300,y:0,z:10}),
        new Tree({x:300,y:0,z:-200}, 1),new Tree({x:300,y:0,z:200}, 1),
        new Tree({x:1000,y:0,z:-200}, 2),new Tree({x:1000,y:0,z:200}, 2),
        new Tree({x:2000,y:0,z:-200}, 3),new Tree({x:2000,y:0,z:200}, 3),
        new Tree({x:3000,y:0,z:-200}, 2),new Tree({x:3000,y:0,z:200}, 4),
        new Tree({x:4000,y:0,z:-200}, 1),new Tree({x:3700,y:0,z:325}, 2),
        new Tree({x:2652,y:0,z:-400}, 3),new Tree({x:2500,y:0,z:700}, 3),
        new Tree({x:1500,y:0,z:-485}, 3),new Tree({x:1500,y:0,z:700}, 3),
        new Tree({x:3500,y:0,z:-200}, 3),new Tree({x:3250,y:0,z:300}, 3),
        new Tree({x:800,y:0,z:-400}, 3),new Tree({x:800,y:0,z:500}, 3),
        new Tree({x:200,y:0,z:-485}, 3),new Tree({x:200,y:0,z:725}, 3),
        new Tree({x:-200,y:0,z:-400}, 3),new Tree({x:-200,y:0,z:600}, 3),
        new Rocks({x:-200,y:0,z:-200}), new Rocks({x:200,y:0,z:200}),
        new Rocks({x:-800,y:0,z:-200}), new Rocks({x:800,y:0,z:200}),
        new Rocks({x:-1000,y:0,z:-300}), new Rocks({x:1000,y:0,z:200}),
        new RockStack({x:55,y:0,z:-1778}, 2),new RockStack({x:1000,y:0,z:1000}, 3),
        new RockStack({x:2000,y:0,z:-2455}, 3),new RockStack({x:3000,y:0,z:2856}, 4),

        new Path({x:149,y:0,z:10}, 1, 'S'),new Path({x:661,y:0,z:10}, 1, 'S'),
        new Path({x:1173,y:0,z:10}, 1, 'S'),new Path({x:1685,y:0,z:10}, 1, 'S'),
        new Path({x:2197,y:0,z:10}, 1, 'S'),new Path({x:2709,y:0,z:10}, 1, 'S'),
        new Path({x:3221,y:0,z:10}, 1, 'S'),new Path({x:3733,y:0,z:10}, 1, 'S'),
        new Path({x:4245,y:0,z:10}, 1, 'S'),
        new Tree({x:-600,y:0,z:-200}, 1),new Tree({x:-600,y:0,z:200}, 2),
        new Tree({x:1300,y:0,z:-200}, 1),new Tree({x:1300,y:0,z:200}, 4),
        new Tree({x:-150,y:0,z:-200}, 2),new Tree({x:-150,y:0,z:200}, 3),
        new Path({x:-363,y:0,z:10}, 1, 'S'),new Path({x:-1131,y:0,z:10}, 2, 'Y'),
        new LightPole({x:3500,y:0,z:200},{y:45},{intensity:0.5,angle:0.5},{intensity:3,angle:1.1}),
        new LightPole({x:1550,y:0,z:-200},{y:30},{intensity:0.5,angle:0.5},{intensity:3,angle:1.1}),
        new LightPole({x:0,y:0,z:200},{y:45},{intensity:0.5,angle:0.5},{intensity:3,angle:1}),
        // Desvio
        new Path({x:-1632.5,y:0,z:-569.5}, 3, 'S'), new Path({x:-1632.5,y:0,z:591.5}, 4, 'S'),
        new Tree({x:-1500,y:0,z:10}, 3),new Tree({x:-1300,y:0,z:-490}, 3),
        new Tree({x:-1970,y:0,z:-255}, 3),new Tree({x:-1950,y:0,z:275}, 3),
        new LightPole({x:-1325,y:0,z:10},{y:0},{intensity:1,angle:0.5},{intensity:5,angle:1.1}),
        // cemiterio
        new Path({x:-2175,y:0,z:1135}, 6, 'L'),
        new Tree({x:-2500,y:0,z:1250}, 3),new Tree({x:-1500,y:0,z:1250}, 3),
        new Tree({x:-1000,y:0,z:500}, 1),new Tree({x:-1900,y:0,z:500}, 1),
        new Tree({x:-1500,y:0,z:3000},2),new Tree({x:-1900,y:0,z:500}, 1),
        new RockStack({x:-2200,y:0,z:1900},1),new RockStack({x:-2200,y:0,z:2200},1),
        new Tree({x:-1500,y:0,z:3000}, 1),new Tree({x:-1900,y:0,z:3000}, 3),
        new Tree({x:-1000,y:0,z:3000}, 3),new Tree({x:-800,y:0,z:3000}, 4),
        new Tree({x:-1000,y:0,z:1500}, 3),new Tree({x:-800,y:0,z:1700}, 4),
        new Tree({x:-200,y:0,z:1500}, 1),new Tree({x:-150,y:0,z:1700}, 4),
        new Tree({x:250,y:0,z:1250}, 3),new Tree({x:120,y:0,z:1174}, 1),
        new Tree({x:350,y:0,z:1000}, 4),new Tree({x:420,y:0,z:945}, 1),
        new Tree({x:650,y:0,z:1200}, 4),new Tree({x:720,y:0,z:1115}, 3),

        new Tree({x:-1500,y:0,z:2500}, 1),new Tree({x:-1900,y:0,z:2500}, 2),
        new Tree({x:-1000,y:0,z:1500}, 3),new Tree({x:-800,y:0,z:1500}, 4),
        new Tree({x:-1000,y:0,z:3000}, 3),new Tree({x:-800,y:0,z:2500}, 4),
        new Tree({x:-200,y:0,z:2250}, 1),new Tree({x:-150,y:0,z:500}, 4),
        new Tree({x:250,y:0,z:3000}, 2),new Tree({x:120,y:0,z:1785}, 1),
        new Tree({x:350,y:0,z:1621}, 4),new Tree({x:420,y:0,z:3574}, 1),
        new Tree({x:650,y:0,z:2510}, 4),new Tree({x:720,y:0,z:500}, 2),

        new Tree({x:1000,y:0,z:1500}, 3),new Tree({x:800,y:0,z:1500}, 1),
        new Tree({x:1000,y:0,z:3000}, 3),new Tree({x:800,y:0,z:2500}, 1),
        new Tree({x:2000,y:0,z:2250}, 1),new Tree({x:1800,y:0,z:500}, 3),
        new Tree({x:2500,y:0,z:3000}, 3),new Tree({x:2800,y:0,z:1785}, 1),
        new Tree({x:3000,y:0,z:1621},3),new Tree({x:3800,y:0,z:3574}, 1),
        new Tree({x:3500,y:0,z:2510}, 1),new Tree({x:4000,y:0,z:500}, 3),

        new Tree({x:3000,y:0,z:750}, 1),new Tree({x:3000,y:0,z:500}, 3),
        new Tree({x:3250,y:0,z:1500}, 3),new Tree({x:3500,y:0,z:1785}, 1),
        new Tree({x:3750,y:0,z:750},3),new Tree({x:3800,y:0,z:3574}, 1),
        new Tree({x:4000,y:0,z:500}, 1),new Tree({x:4000,y:0,z:500}, 3),

        new Grave({x:-1550,y:0,z:1850}), new Grave({x:-1550,y:0,z:2150}),
        new LightPole({x:-1700,y:0,z:1450},{y:90},{intensity:0.5,angle:0.5},{intensity:3,angle:1}),

        // casa
        new Path({x:-2175.5,y:0,z:-1112.5}, 5, 'R'),new Tree({x:-2500,y:0,z:-1250},3),
        new Tree({x:-1500,y:0,z:-1250}, 1),new Tree({x:-1000,y:0,z:-500}, 1),
        new Tree({x:4000,y:0,z:-1250}, 1),new Tree({x:4000,y:0,z:-500},1),
        new Tree({x:3250,y:0,z:-750}, 3),new Tree({x:3250,y:0,z:-250}, 2),
        new Tree({x:2500,y:0,z:-800}, 4),new Tree({x:2500,y:0,z:-300}, 1),
        new Tree({x:1750,y:0,z:-600}, 1),new Tree({x:1750,y:0,z:-400}, 3),
        new Tree({x:1000,y:0,z:-400}, 2),new Tree({x:1000,y:0,z:-700}, 1),
        new Tree({x:250,y:0,z:-600}, 1),new Tree({x:250,y:0,z:-500}, 3),

        new Tree({x:0,y:0,z:-1250}, 1),new Tree({x:-1250,y:0,z:-2500},1),
        new Tree({x:750,y:0,z:-2500}, 3),new Tree({x:-500,y:0,z:-3000}, 4),
        new Tree({x:1500,y:0,z:-3000}, 4),new Tree({x:250,y:0,z:-3500}, 1),
        new Tree({x:2250,y:0,z:-2750}, 1),new Tree({x:1000,y:0,z:-2700}, 3),
        new Tree({x:3000,y:0,z:-2500}, 3),new Tree({x:1750,y:0,z:-2200}, 1),
        new Tree({x:3750,y:0,z:-1500}, 1),new Tree({x:2500,y:0,z:-2100}, 3),

        new Tree({x:4000,y:0,z:-1500}, 1),new Tree({x:4000,y:0,z:-1200},1),
        new Tree({x:3250,y:0,z:-1000}, 3),new Tree({x:3250,y:0,z:-3000}, 3),
        new Tree({x:2500,y:0,z:-400}, 4),new Tree({x:2500,y:0,z:-3200}, 1),
        new Tree({x:1750,y:0,z:-300}, 1),new Tree({x:1750,y:0,z:-1750}, 3),
        new Tree({x:1000,y:0,z:-2000}, 3),new Tree({x:1000,y:0,z:-1000}, 1),
        new Tree({x:250,y:0,z:-1700}, 1),new Tree({x:250,y:0,z:-1000}, 3),
        new House ({x:-2150,y:0,z:-2500}),
        new LightPole({x:-2300,y:0,z:-2000},{y:0},{intensity:1,angle:0.5},{intensity:3,angle:1})
    ];

    /**
     * Metodo que adiciona a lista de objectos a cena
     */
    app.add(objs);

</script>
</body>
</html>