<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <link rel="stylesheet" href="css/cg.css">
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>
<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">The Red Rose ! - Carrega aqui para comecar!</span>
        <br />
        (W, A, S, D = Mover, RATO = Olhar em volta, ESC = Retornar ao menu, Som tem de estar ligado)
        <br />
        Pedro Roldan 21501217- Leandro Moreira 21601599 ISMAT 2017
    </div>
</div>

<div id="gameState">
    <div id="conditionWin">
        <span style="font-size:40px">The Red Rose ! - VITORIA!</span>
        <br />
        F5 - Para jogar novamente!
    </div>
    <div id="conditionLoose">
        <span style="font-size:40px">The Red Rose ! - DERROTA!</span>
        <br />
        F5 - Para jogar novamente!
    </div>
    <br />

</div>

<table id ="headerBox" >
    <tbody>
    <tr>
        <td>The Red Rose Aventure</td>
        <td></td>
        <td></td>
        <td></td>
        <td>Tempo restante:</td>
        <td><span id="timer"></span></td>
        <td>Objectos recuperados:</td>
        <td><span id="objects"></span></td>
        <td></td>
    </tr>
    </tbody>
</table>

<table id ="footerBox" >
    <tbody>
    <tr>
        <td width="20%"></td>
        <td style="white-space: nowrap;"><span id="playersLife"> </span><span id="hitMarker"></span></td>
        <td width="20%"></td>
    </tr>
    </tbody>
</table>

<script src="js/three.js"></script>
<script src="js/physi.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/MTLLoader.js"></script>

<script>
    var myCanvas = document.getElementById('myCanvas');
    var blocker = document.getElementById( 'blocker' );             //chama o blocker, para ativacao do utilizador e comecar o lock
    var instructions = document.getElementById( 'instructions' );   //janela de instrucoes
    var headerBox = document.getElementById('headerBox');
    var footerBox = document.getElementById('footerBox');
    var hitMarker = document.getElementById('hitMarker');
    var conditionWin = document.getElementById('conditionWin');
    var conditionLoose = document.getElementById('conditionLoose');
    var gameState = document.getElementById('gameState');

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        //MOVEMENT_SPEED = 2250,
        MOVEMENT_SPEED = 10000,
        SHADOWMAPWIDTH = 2048,
        SHADOWMAPHEIGHT = 2048,
        physics_framerate = 1000 / 60,
        player;

    var scene, renderer, camera, controls, spline, monsterSpline;

    var vector = new THREE.Vector3();

    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var updateCam = 1;  //variavel para atualizar a camera, so passa a 1 apos o primeiro movimentos
    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    var sound = null;
    var tangent = new THREE.Vector3();
    var axis = new THREE.Vector3();
    var up = new THREE.Vector3(0, 1, 0);
    var counter = 0 ;
    var monsterCounter = 0 ;
    var flieMesh = null;
    var monsterMesh = null;
    var playerProfile = null;
    var endTime = 60*5; // 5 minutos
    var keys = [];
    var toFind = 5;
    var minutes = 0;
    var seconds = 0;
    var isRunning = true;

    document.getElementById('timer').innerHTML = '05' + ":" + '00';
    document.getElementById('objects').innerHTML = '0' + "/" + '5';

    /**
     * Classe para jogador
     */
    class Player {
        constructor(id){
            this.id             = id;           // identificador interno do jogador
            this.life           = 10;           // vida inicial do jogador
            this.isAlive        = true;
            this.objectives     = 0;
            this.hit            = 0;
        };

        setUpdate(life) {
            if (this.life !== 0) {
                this.life -= life;        // update a vida do jogador
                //console.log("hit");

                setTimeout(function() { // inicia o delay
                    document.getElementById('hitMarker').innerHTML = '-' + life;
                    var fade = document.getElementById("hitMarker");
                    fade.style.opacity = 1; // opacidade a 1
                    var timerId = setInterval(function() { // inicia loop de intervalo
                        var opacity = fade.style.opacity; // get da opacidade
                        if (opacity === 0) {
                            clearInterval(timerId);
                        } else {
                            fade.style.opacity = opacity - 0.05; // remove 0.05 da opacidade
                        }
                    }, 100); // corre a cada 0.1 segundos
                }, 5); // espera e corre apos 0.05 segundos

            } else {

                //console.log("You are dead");
            }

        }


    }

    /**
     * Classe generico
     */
    class Obj{
        constructor(){}
    }

    /**
     * Metodo construtor do modelo de uma chave
     */
    class Keys extends Obj{
        constructor(position){
            super();

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/sg-golden-key.mtl", function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/sg-golden-key.obj", function (object) {
                    object.scale.set( 2, 2, 2);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;
                    object.rotation.y = Math.PI/2;
                    object.rotation.z = Math.PI/2;

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            });

            this.geometry = new THREE.BoxGeometry(30, 10, 20);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.keyMesh = new THREE.Mesh(this.geometry, this.material);

            this.keyMesh.position.x = position.x + 5;
            this.keyMesh.position.y = position.y + 5;
            this.keyMesh.position.z = position.z;
            this.keyMesh.position.z = position.z;
            scene.add(this.keyMesh);
            keys.push(this.keyMesh);

        }

        getMesh(){
            return this.keyMesh;
        }
    }

    /**
     * Metodo construtor do modelo de monte de rochas
     */
    class RockStack extends Obj{
        constructor(position, stackColor){
            super();

            var materialPath;

            // tipo de rochas
            switch (stackColor) {

                case 1:
                    materialPath = "images/rock1.jpg";
                    break;

                case 2:
                    materialPath = "images/rock2.jpg";
                    break;

                case 3:
                    materialPath = "images/rock3.jpg";
                    break;

                case 4:
                    materialPath = "images/rock4.jpg";
                    break;


            }

            // carrega o material escolhido
            var material = new THREE.MeshPhongMaterial();
            material.map = new THREE.ImageUtils.loadTexture(materialPath);

            //carrega o modelo
            var objLoader = new THREE.OBJLoader();
            objLoader.load( "models/blender_rocks.obj", function (object) {
                object.scale.set( 25, 25, 25);
                object.position.x = position.x;
                object.position.y = position.y;
                object.position.z = position.z;

                //ativa as sombras
                object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        child.castShadow = true;
                        child.material = material;
                    }
                });

                //adiciona o modelo
                scene.add( object );

            });

            //---------- physics test ------------//
            this.geometry = new THREE.BoxGeometry(110, 60, 120);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.physicsMesh = new physijs.Box(this.geometry, this.material, { mass: 2000, type: 'RIGID' } );

            this.physicsMesh.position.x = position.x-5;
            this.physicsMesh.position.y = position.y + 30;
            this.physicsMesh.position.z = position.z-60;
            scene.add(this.physicsMesh);
            //---------- physics test ------------//
        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Metodo construtor do modelo de uma rocha
     */
    class Rocks extends Obj{
        constructor(position){
            super();

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/Rock1.mtl", function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/Rock1.obj", function (object) {
                    object.scale.set( 50, 50, 50);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            });

            //---------- physics test ------------//
            this.geometry = new THREE.BoxGeometry(150, 75, 170);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.physicsMesh = new physijs.Box(this.geometry, this.material,  { mass: 2000, type: 'RIGID' });

            this.physicsMesh.position.x = position.x - 10;
            this.physicsMesh.position.y = position.y+ 75/2;
            this.physicsMesh.position.z = position.z;
            scene.add(this.physicsMesh);
            //---------- physics test ------------//

        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Metodo construtor dos modelos das arvores
     */
    class Tree extends Obj{
        constructor(position, treeType){
            super();

            var mtlPath, objPath;

            //verifica modelo da arvore
            switch (treeType) {

                case 1:
                    mtlPath = "models/DeadTree1.mtl";
                    objPath = "models/DeadTree1.obj";
                    break;

                case 2: //mini 1
                    mtlPath = "models/DeadTree2.mtl";
                    objPath = "models/DeadTree2.obj";
                    break;

                case 3:
                    mtlPath = "models/DeadTree3.mtl";
                    objPath = "models/DeadTree3.obj";
                    break;

                case 4: //mini 3
                    mtlPath = "models/DeadTree4.mtl";
                    objPath = "models/DeadTree4.obj";
                    break;


            }

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( mtlPath , function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( objPath, function (object) {

                    //escala dos modelos
                    if (treeType === 4){
                        object.scale.set(0.5, 0.5, 0.5);
                    } else {
                        object.scale.set(1, 1, 1);
                    }

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;
                    object.side = THREE.BackSide;

                    scene.add( object );
                });

            });

            //---------- physics test ------------//
            switch (treeType) {

                case 1:
                    this.geometry = new THREE.CylinderGeometry(30, 30, 500);
                    //this.material = new THREE.MeshPhongMaterial();
                    this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
                    this.physicsMesh = new physijs.Cylinder(this.geometry, this.material, { mass: 2000, type: 'RIGID' });

                    this.physicsMesh.position.x = position.x-7.5;
                    this.physicsMesh.position.y = position.y + 250;
                    this.physicsMesh.position.z = position.z-7.5;
                    break;

                case 2: //mini 1
                    this.geometry = new THREE.CylinderGeometry(15, 15, 200);
                    //this.material = new THREE.MeshPhongMaterial();
                    this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
                    this.physicsMesh = new physijs.Cylinder(this.geometry, this.material, { mass: 2000, type: 'RIGID' });

                    this.physicsMesh.position.x = position.x-5;
                    this.physicsMesh.position.y = position.y + 100;
                    this.physicsMesh.position.z = position.z-5;
                    break;

                case 3:
                    this.geometry = new THREE.CylinderGeometry(85, 85, 850);
                    //this.material = new THREE.MeshPhongMaterial();
                    this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
                    this.physicsMesh = new physijs.Cylinder(this.geometry, this.material, { mass: 2000, type: 'RIGID' });

                    this.physicsMesh.position.x = position.x;
                    this.physicsMesh.position.y = position.y + 425;
                    this.physicsMesh.position.z = position.z;
                    break;

                case 4: //mini 3
                    this.geometry = new THREE.CylinderGeometry(30, 30, 425);
                    //this.material = new THREE.MeshPhongMaterial();
                    this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
                    this.physicsMesh = new physijs.Cylinder(this.geometry, this.material, { mass: 2000, type: 'RIGID' });

                    this.physicsMesh.position.x = position.x;
                    this.physicsMesh.position.y = position.y + 212.5;
                    this.physicsMesh.position.z = position.z;
                    break;


            }
            //---------- physics test ------------//


        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Motodo construtor para o sinal de informacao
     */
    class InformationPlate extends Obj{
        constructor(size,position){
            super();

            //tabua principal
            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            var woodTexture = THREE.ImageUtils.loadTexture('images/wood-texture.jpg'); //new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
            this.material = new THREE.MeshPhongMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.rotation.y = Math.PI / 2;
            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;

            //------ Grave -----//

            //tabua do grave
            this.geometry = new THREE.BoxGeometry(20, 100, 5);
            this.gravePointer = new THREE.Mesh(this.geometry, this.material);
            this.gravePointer.position.x = -50;
            this.gravePointer.position.y = 240;
            this.gravePointer.position.z = 6.5;

            this.gravePointer.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.castShadow = true;
                }
            });

            this.gravePointer.rotation.z = Math.PI / 2;

            //----- Parafusos -----//
            this.nailMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });

            this.radius = .5;
            this.segments = 32; //<-- Increase or decrease for more resolution I guess

            this.circleGeometry = new THREE.CircleGeometry( this.radius, this.segments );
            this.circle1 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );

            this.circle1.position.x = 5;
            this.circle1.position.y = -46;
            this.circle1.position.z = 2.6;
            this.gravePointer.add( this.circle1 );

            this.circle2 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle2.position.x = -5;
            this.circle2.position.y = -46;
            this.circle2.position.z = 2.6;
            this.gravePointer.add( this.circle2 );

            // definicao do texto na tabua
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            this.context.font = "Bold 15px Arial";
            this.context.fillStyle = "rgb(0,0,0)";
            this.context.fillText('GRAVEYARD', 0, 20);

            // texture
            this.texture = new THREE.Texture(this.canvas);
            this.texture.needsUpdate = true;

            // material
            this.material = new THREE.MeshPhongMaterial( {map: this.texture, side:THREE.DoubleSide } );
            this.material.transparent = true;

            // grave text mesh
            this.graveTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(this.canvas.width, this.canvas.height),
                this.material
            );

            // posicionar na tabua o texto
            this.graveTextMesh.position.set(-60,-102,2.6);
            this.graveTextMesh.rotation.z = -Math.PI / 2;

            this.gravePointer.add( this.graveTextMesh );

            this.mesh.add(this.gravePointer);

            //------ Mansion -----//

            // tabua da mansion
            this.geometry = new THREE.BoxGeometry(20, 100, 5);
            this.material = new THREE.MeshPhongMaterial({map:woodTexture,side:THREE.DoubleSide});
            this.mansionPointer = new THREE.Mesh(this.geometry, this.material);
            this.mansionPointer.position.x = 50;
            this.mansionPointer.position.y = 220;
            this.mansionPointer.position.z = 6.5;

            this.mansionPointer.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.castShadow = true;
                }
            });

            this.mansionPointer.rotation.z = Math.PI / 2;

            //----- Parafusos -----//

            this.circle3 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle3.position.x = -15;
            this.circle3.position.y = -54;
            this.circle3.position.z = 2.6;
            this.gravePointer.add( this.circle3 );

            this.circle4 = new THREE.Mesh( this.circleGeometry, this.nailMaterial );
            this.circle4.position.x = -25;
            this.circle4.position.y = -54;
            this.circle4.position.z = 2.6;
            this.gravePointer.add( this.circle4 );

            // definicao do texto na tabua
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            this.context.font = "Bold 15px Arial";
            this.context.fillStyle = "rgb(0,0,0)";
            this.context.fillText('MANSION', 0, 20);

            // texture
            this.texture = new THREE.Texture(this.canvas);
            this.texture.needsUpdate = true;

            // material
            this.material = new THREE.MeshPhongMaterial( {map: this.texture, side:THREE.DoubleSide } );
            this.material.transparent = true;

            // mansion text mesh
            this.mansionTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(this.canvas.width, this.canvas.height),
                this.material
            );

            // posicionar na tabua o texto
            this.mansionTextMesh.position.set(-60,-120,2.61);
            this.mansionTextMesh.rotation.z = -Math.PI / 2;

            this.mansionPointer.add(this.mansionTextMesh );

            this.mesh.add(this.mansionPointer);


            //this.mesh.rotation.y = Math.PI / 2; //tabua de frente para o utilizador

            //ativa as sombras
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = false;

            //---------- physics test ------------//
            this.geometry = new THREE.BoxGeometry(size.width*7, size.height/2, size.depth*2);
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            //this.material = new THREE.MeshPhongMaterial();
            this.physicsMesh = new physijs.Box(this.geometry, this.material, { mass: 2000, type: 'RIGID' });

            this.physicsMesh.position.x = position.x;
            this.physicsMesh.position.y = position.y + (size.height/4);
            this.physicsMesh.position.z = position.z;

            this.physicsMesh.rotation.y = Math.PI / 2;

            //scene.add(this.physicsMesh);
            //---------- physics test ------------//
        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Metodo construtor do caminho
     */
    class Path extends Obj {
        constructor(position, rotation, type) {
            super();

            //tipo de caminho
            switch (type) {

                case 'S':   //direito
                    this.geometry = new THREE.PlaneGeometry(512, 256);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/dirt_road.jpg");
                    break;

                case 'Y':   //Y
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/Y_road.png");
                    this.material.transparent = true;
                    break;

                case 'L':   //esquerda
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/left_road.png");
                    this.material.transparent = true;
                    break;

                case 'R':   //direita
                    this.geometry = new THREE.PlaneGeometry(1024, 1024);
                    this.material = new THREE.MeshPhongMaterial();
                    this.material.map = THREE.ImageUtils.loadTexture("images/right_road.png");
                    this.material.transparent = true;
                    break;

            }

            //cria e posiciona a mesh
            //this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh = new physijs.Box(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y+.1;
            this.mesh.position.z = position.z;

            //rotacao da mesh, depende do path
            switch (rotation) {
                case 1: // Vertical
                    this.mesh.rotation.x = -Math.PI / 2;
                    break;

                case 2: // Y
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 2;
                    break;

                case 3: // /
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = -Math.PI / 4;
                    break;

                case 4: // \
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 4;
                    break;

                case 5: // / -> right
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = Math.PI / 4;
                    break;

                case 6: // left <- \
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.rotation.z = -(5 * Math.PI / 4);
                    break;

            }

            this.mesh.receiveShadow = true;

        }

        getMesh() {
            return this.mesh;
        }

    }

    /**
     * Metodo construtor do chao da cena
     */
    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshPhongMaterial(); // lambert nao permite a correcta iluminacao

            this.material.map = THREE.ImageUtils.loadTexture('images/floor.jpg');
            //this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh = new physijs.Box( this.geometry, this.material, {friction: 10000});

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;

            this.mesh.receiveShadow = true;

            //physics
            this.geometry = new THREE.PlaneGeometry(15000, 15000);
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            //this.physicsMesh = new THREE.Mesh(this.geometry, this.material);
            this.physicsMesh = new physijs.Box( this.geometry, this.material, {friction: 10000});

            this.physicsMesh.position.x = position.x;
            this.physicsMesh.position.y = position.y;
            this.physicsMesh.position.z = position.z;
            this.physicsMesh.rotation.x = -Math.PI/2;
            scene.add(this.physicsMesh);
        }

        getMesh(){
            return this.mesh;
        }
    }

    /**
     * Metodo construtor de uma sepultura
     */
    class Grave extends Obj{
        constructor(position){
            super();

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/dirt_grave.mtl", function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/dirt_grave.obj", function (object) {
                    object.scale.set( 4, 4, 4);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    object.rotation.y = Math.PI / 2;

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            });

            // aplicação do motor de fisica
            this.geometry = new THREE.BoxGeometry(355, 100, 150);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.physicsMesh = new physijs.Box(this.geometry, this.material,  { mass: 2000, type: 'RIGID' });

            this.physicsMesh.position.x = position.x;
            this.physicsMesh.position.y = position.y + 33;
            this.physicsMesh.position.z = position.z;

//            this.geometry = new THREE.BoxGeometry(30, 100, 80);
//            this.material = new THREE.MeshPhongMaterial({color: 0x00ff00});
//            //this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
//            this.graveCrossMesh = new physijs.Box(this.geometry, this.material,  { mass: 2000, type: 'RIGID' });
//            this.graveCrossMesh.position.x = position.x - 165;
//            this.graveCrossMesh.position.y = position.y+50;
//            this.graveCrossMesh.position.z = position.z;
//
//            scene.add(this.graveCrossMesh);

        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Metodo construtor de uma casa
     */
    class House extends Obj{
        constructor(position){
            super();

            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/casa.mtl", function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/casa.obj", function (object) {
                    object.scale.set( 13, 13, 13);
                    object.position.x = position.x;
                    object.position.y = position.y;
                    object.position.z = position.z;

                    object.rotation.y = -Math.PI/2;

                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                        }
                    });

                    scene.add( object );

                });

            });

            // aplicação do motor de fisica
            this.geometry = new THREE.BoxGeometry(830, 750, 850);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.houseMesh = new physijs.Box(this.geometry, this.material,  { mass: 2000, type: 'RIGID' });

            this.houseMesh.position.x = position.x;
            this.houseMesh.position.y = position.y+325;
            this.houseMesh.position.z = position.z;
            scene.add(this.houseMesh);


        }

        getMesh(){
            return this.physicsMesh;
        }
    }

    /**
     * Metodo construtor de um poste de luz
     */
    class LightPole extends Obj{
        constructor(position,rotation,lamp,pole){
            super();

            this.geometry = new THREE.CubeGeometry(100, 10, 10);
            this.material = new THREE.MeshPhongMaterial();
            this.material.map = THREE.ImageUtils.loadTexture('images/wood-texture.jpg');
            this.armMesh = new THREE.Mesh( this.geometry, this.material );
            //this.armMesh = new physijs.Box( this.geometry, this.material );

            this.armMesh .position.x = 10;
            this.armMesh .position.y = 180;
            this.armMesh .position.z = 0;
            this.armMesh .castShadow = true;

            this.geometry = new THREE.CubeGeometry(20, 40, 20);
            this.material = new THREE.MeshPhongMaterial({color: 0xfff500});
            //this.material.map = THREE.ImageUtils.loadTexture('images/wood-texture.jpg');
            this.lampMesh = new THREE.Mesh( this.geometry, this.material );
            //this.lampMesh = new physijs.Box( this.geometry, this.material );

            this.lampMesh.position.x = 50;
            this.lampMesh.position.y = 155;
            this.lampMesh.position.z = 0;
            this.lampMesh.castShadow = true;

            var numPoints = 50;

            spline = new THREE.SplineCurve3([
                new THREE.Vector3(-100, 0, 0),
                new THREE.Vector3(0, 0, 100),
                new THREE.Vector3(100, 0, 0),
                new THREE.Vector3(0, 0, -100),
                new THREE.Vector3(-100, 0, 0)
                ]);

            var material = new THREE.LineBasicMaterial({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = spline.getPoints(numPoints);

            for (var i = 0; i < splinePoints.length; i++) {
                geometry.vertices.push(splinePoints[i]);
            }

            var line = new THREE.Line(geometry, material);
            line.visible = false;

            //load a spline mesh invisivel para adicionar a mosca
            this.geometry = new THREE.CubeGeometry(20, 40, 20);
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            flieMesh = new THREE.Mesh( this.geometry, this.material );
            flieMesh.position.x = 100;
            flieMesh.position.y = 0;
            flieMesh.position.z = 0;
            flieMesh.castShadow = true;

            //carrega o mtl
            var mtLoader = new THREE.MTLLoader();
            mtLoader.load( "models/fly.mtl", function (materials) {

                materials.preload();

                //carrega o obj
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load( "models/fly.obj", function (object) {
                    object.scale.set( 0.5, 0.5, 0.5);
                    object.rotation.y = -Math.PI/4;
                    object.rotation.z = Math.PI/2;
                    object.castShadow = true;

                    //ativa as sombras
                    object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            child.castShadow = true;
                            child.material.color.setHex(0x000000);
                        }
                    });

                    flieMesh.add(object);

                });

            });

            this.lampMesh.add(line);
            this.lampMesh.add(flieMesh);

            setInterval(this.moveFlies, 100);

            this.geometry = new THREE.CylinderGeometry(10, 10, 350);
            this.material = new THREE.MeshPhongMaterial();
            this.material.map = THREE.ImageUtils.loadTexture('images/iron.jpg');
            this.poleMesh = new THREE.Mesh( this.geometry, this.material );
            //this.poleMesh = new physijs.Cylinder( this.geometry, this.material );

            this.poleMesh.position.x = position.x;
            this.poleMesh.position.y = position.y + 150;
            this.poleMesh.position.z = position.z;
            this.poleMesh.rotation.y = rotation.y;
            this.poleMesh.castShadow = true;

            this.poleMesh.add(this.armMesh);
            this.poleMesh.add(this.lampMesh);

            var poleLight = new THREE.SpotLight(0x1b150a);
            poleLight.position.set(this.lampMesh.position.x,this.lampMesh.position.y,this.lampMesh.position.z);
            poleLight.target = this.poleMesh;
            poleLight.castShadow = true;
            poleLight.intensity = pole.intensity;
            poleLight.angle = pole.angle;
            poleLight.penumbra = 0.1;
            poleLight.shadowCameraVisible = true;
            poleLight.shadow.mapSize.width = SHADOWMAPWIDTH;
            poleLight.shadow.mapSize.height = SHADOWMAPHEIGHT;

            poleLight.shadow.camera.near = 100;
            poleLight.shadow.camera.far = 2048;
            poleLight.shadow.camera.fov = 30;

            this.poleMesh.add(poleLight);

            var lampLight = new THREE.SpotLight(0xffffff);
            lampLight.position.set(this.lampMesh.position.x,this.lampMesh.position.y-10,this.lampMesh.position.z);
            lampLight.target = this.lampMesh;
            lampLight.intensity = lamp.intensity;
            lampLight.angle = lamp.angle;
            lampLight.penumbra = 0.8;
            lampLight.castShadow = true;
            lampLight.shadowCameraVisible = true;
            lampLight.shadow.mapSize.width = SHADOWMAPWIDTH;
            lampLight.shadow.mapSize.height = SHADOWMAPHEIGHT;

            lampLight.shadow.camera.near = 100;
            lampLight.shadow.camera.far = 2048;
            lampLight.shadow.camera.fov = 30;

            this.lampMesh.add(lampLight);
            scene.add(this.poleMesh);


            this.geometry = new THREE.BoxGeometry(120, 370, 40);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            this.physicsMesh = new physijs.Box(this.geometry, this.material, { mass: 2000, type: 'RIGID', friction: 1 });

            this.physicsMesh.position.x = position.x;
            this.physicsMesh.position.y = position.y + 185;
            this.physicsMesh.position.z = position.z;
            this.physicsMesh.rotation.y = rotation.y;

            scene.add(this.physicsMesh);

        }

        getMesh(){
            return this.physicsMesh;
        }

        moveFlies() {
            if (counter <= 1) {
                flieMesh.position.copy( spline.getPointAt(counter) );

                tangent = spline.getTangentAt(counter).normalize();

                axis.crossVectors(up, tangent).normalize();

                var radians = Math.acos(up.dot(tangent));

                flieMesh.quaternion.setFromAxisAngle(axis, radians);

                counter += 0.005
            } else {
                counter = 0;
            }
        }
    }

    /**
     * Metodo construtor de um Monstro
     */
    class Monster extends Obj{
        constructor(){
            super();

            this.geometry = new THREE.BoxGeometry(400, 160, 200);
            //this.material = new THREE.MeshPhongMaterial();
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            monsterMesh = new physijs.Box(this.geometry, this.material, { mass: 2000, type: 'RIGID', friction: 1 });

            var loader = new THREE.JSONLoader();
            loader.load( 'models/monster.js', function ( geometry, materials ) {

                var mesh = new THREE.Mesh( geometry, materials );
                mesh.position.set(-150, -60, -15);
                mesh.scale.set( .20, .20, .20 );

                monsterMesh.add(mesh);

            } );

            var numPoints = 50;

            monsterSpline = new THREE.SplineCurve3([
                new THREE.Vector3(-2800, 80, -3200),
                new THREE.Vector3(-2800, 80, -1800),
                new THREE.Vector3(-1600, 80, -1800),
                new THREE.Vector3(-1600, 80, -3200),
                new THREE.Vector3(-2800, 80, -3200)
            ]);


            var material = new THREE.LineBasicMaterial({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = monsterSpline.getPoints(numPoints);

            for (var i = 0; i < splinePoints.length; i++) {
                geometry.vertices.push(splinePoints[i]);
            }

            var line = new THREE.Line(geometry, material);
            line.visible = false;

            scene.add(line);
            monsterMesh.position.copy( monsterSpline.getPointAt(monsterCounter) );
            setInterval(this.moveMonster, 10);

        }

        getMesh(){
            return monsterMesh;
        }

        moveMonster() {
            if (monsterCounter <= 1) {
                monsterMesh.position.copy( monsterSpline.getPointAt(monsterCounter) );

//                tangent = monsterSpline.getTangentAt(monsterCounter).normalize();
//
//                axis.crossVectors(up, tangent).normalize();
//
//                var radians = Math.acos(up.dot(tangent));
//
//                monsterMesh.quaternion.setFromAxisAngle(axis, radians);

                monsterCounter += 0.0005
            } else {
                monsterCounter = 0;
            }
        }
    }

    /**
     * Metodo que inicializa a aplicacao
     */
    class Aplication{

        /**
         * Metodo construtor
         */
        constructor() {
            this.objects = [];

            this.checkCompatibility(); //verifica a compatibilidade do PointerLockControls com o browser

            this.createScene();
        }

        /**
         * Metodo que cria a cena da aplicação
         */
        createScene() {
            //SCENE
            scene = new physijs.Scene('js/physijs-worker.js');
            scene.gravity = new THREE.Vector3( 0, -5000, 0 );

            //scene.fog = new THREE.Fog( 0x000000, .5, 2000 );

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.y = 180;

            //Cria AudioListener e adiciona a camera
            var listener = new THREE.AudioListener();
            camera.add( listener );

            // Cria um audio source global
            sound = new THREE.Audio( listener );
            var audioLoader = new THREE.AudioLoader();

            //Carrega o som e set o buffer de audio
            audioLoader.load( 'sounds/348997_klankbeeld_horror-ambience-160531-0886.ogg', function( buffer ) {
                sound.setBuffer( buffer );
                sound.setLoop(true);
                sound.setVolume(0.5);
                //sound.play();
            });

            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            renderer.shadowMap.enabled = true;
            renderer.shadowMapSoft = true;
            renderer.shadowCameraNear = 3;
            renderer.shadowCameraFar = camera.far;
            renderer.shadowCameraFov = 50;
            renderer.shadowMapBias = 0.0039;
            renderer.shadowMapDarkness = 0.5;
            renderer.shadowMapWidth = SHADOWMAPWIDTH;
            renderer.shadowMapHeight = SHADOWMAPHEIGHT;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // to antialias the shadow

            document.body.appendChild(renderer.domElement);

            var player_geometry = new THREE.CylinderGeometry(50, 50, 210);
            //var player_material = new THREE.MeshPhongMaterial();
            var player_material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            player = new physijs.Cylinder( player_geometry, player_material, { mass: 0, type: 'RIGID' });
            player.rotation.y = Math.PI/2;
            //player.position.set(4000, 100, 0);

            scene.add(player);

            this.physicColision(player);

            //CAMERA CONTROL (As restricoes da camera foram efetuadas no PointerLockControls.js, linha 26)
            controls = new THREE.PointerLockControls( camera );
            controls.getObject().rotation.y = Math.PI/2;
            controls.getObject().position.set( 4000, 0, 0);
            scene.add( controls.getObject() );

            this.createSkyBox(); // cria skybox e iluminacao correspondente

            //KEY LISTENERS
            document.addEventListener( 'keydown', this.onKeyDown, false );      //Listener da tecla ativada
            document.addEventListener( 'keyup', this.onKeyUp, false );          //listener para desativar as teclas
            window.addEventListener( 'resize', this.onWindowResize, false );    //listener para o resize

            this.newPlayer();
            this.startTimer(endTime);
            this.render();

        }

        /**
         * Metodo que inicia um timer countdown
         */
        startTimer(duration) {
            var timer = duration;
            var interval = setInterval(function () {
                minutes = parseInt(timer / 60, 10);
                seconds = parseInt(timer % 60, 10);

                minutes = minutes < 10 ? "0" + minutes : minutes;
                seconds = seconds < 10 ? "0" + seconds : seconds;

                document.getElementById('timer').innerHTML = minutes + ":" + seconds;

                if (--timer < 0) {
                    clearInterval(interval);
                    controls.enabled = false;
                    playerProfile.isAlive = false;
                    gameState.style.display = 'block';
                    conditionLoose.style.display = 'block';
//                    timer = duration;
                }
            }, 1000);
        }

        newPlayer () {
            playerProfile = new Player(1);
        }

        /**
         * Metodo que controla o evento KeyUp do teclado
         */
        onKeyUp ( event ) {
            switch( event.keyCode ) {
                case 87: // w
                    moveForward = false;
                    break;
                case 65: // a
                    moveLeft = false;
                    break;
                case 83: // s
                    moveBackward = false;
                    break;
                case 68: // d
                    moveRight = false;
                    break;
            }
        };

        /**
         * Metodo que controla o evento KeyDown do teclado
         */
        onKeyDown ( event ) {
            switch ( event.keyCode ) {
                case 87: // w
                    moveForward = true;
                    break;
                case 65: // a
                    moveLeft = true;
                    break;
                case 83: // s
                    moveBackward = true;
                    break;
                case 68: // d
                    moveRight = true;
                    break;
                case 27: // esc
                    sound.stop();
                    break;
            }
        };

        /**
         * Metodo que verifica compatibilidade do browser
         */
        checkCompatibility () {
            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;
                        controls.enabled = true;
                        blocker.style.display = 'none';
                        //headerBox.style.display = 'inline';
                        //footerBox.style.display = 'block';

                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        instructions.style.display = '';
                    }
                };


                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';



                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    element.requestPointerLock();
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

        }

        /**
         * Metodo que controla o evento Window Resize do browse
         */
        onWindowResize() {
            //playerProfile.setUpdate(2);
            camera.aspect = window.innerWidth / window.innerHeight;
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.updateProjectionMatrix();
        }

        /**
         * Metodo que inicia o motor de fisica e associa a cena fazendo render
         * */
        onStep() {
            renderer.render( scene, camera );
            if (physijs.is_stepping === false) {
                setTimeout(scene.step.bind(scene, physics_framerate / 1000, undefined, this.onStep), physics_framerate);
            }
        }

        /**
         * Metodo que efetua o render da cena
         */
        render(){

            requestAnimationFrame(() => {
                this.render();
                scene.step( physics_framerate / 1000, undefined, this.onStep );
            });

            if ( controlsEnabled ) { //Aplica o movimento com o WASD
                var time = performance.now();
                var delta = ( time - prevTime ) / 1000;
                var velocidadeMin = 10;

                if ( isRunning ) {
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;

                    if (moveForward) {
                        velocity.z -= MOVEMENT_SPEED * delta;
                        updateCam = 1;    //confirma a existencia de um movimento
                    }

                    if (moveBackward) {
                        velocity.z += MOVEMENT_SPEED * delta;
                        updateCam = 1;    //confirma a existencia de um movimento
                    }

                    if (moveLeft) {
                        velocity.x -= MOVEMENT_SPEED * delta;
                        updateCam = 1;    //confirma a existencia de um movimento
                    }

                    if (moveRight) {
                        velocity.x += MOVEMENT_SPEED * delta;
                        updateCam = 1;    //confirma a existencia de um movimento
                    }

                    controls.getObject().translateX(velocity.x * delta);
                    controls.getObject().translateZ(velocity.z * delta);
                }

                prevTime = time;

                player.position.set(controls.getObject().position.x , controls.getObject().position.y+100, controls.getObject().position.z);
            }

            document.getElementById('playersLife').innerHTML = "";
            if (playerProfile.life !== 0){
                for (var i=0; i<= playerProfile.life; i++){
                    document.getElementById('playersLife').innerHTML += '|';
                }
            } else {
                document.getElementById('playersLife').innerHTML = '-';
            }

            if (playerProfile.life === 0) {
                isRunning=false;
                playerProfile.isAlive = false;
            }

            if (playerProfile.isAlive === false) {
                controls.enabled = false;
                gameState.style.display = 'block';
                conditionLoose.style.display = 'block';
            }
        }

        /**
         * Metodo que adiciona mesh a partir de uma lista de objectos
         */
        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

        createSkyBox() {

            var urls = [
                "images/nightsky_rt.jpg", "images/nightsky_lf.jpg",
                "images/nightsky_up.jpg", "images/nightsky_dn.jpg",
                 "images/nightsky_bk.jpg", "images/nightsky_ft.jpg"];


            var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
            cubemap.format = THREE.RGBFormat;

            var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
            shader.uniforms['tCube'].value = cubemap; // apply textures to shader

            // shader material
            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: shader.fragmentShader,
                vertexShader: shader.vertexShader,
                uniforms: shader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });


            // skybox mesh
            var skyboxSize = 8000;

            var skybox = new THREE.Mesh(
                new THREE.CubeGeometry(skyboxSize, skyboxSize, skyboxSize),
                skyBoxMaterial
            );

            skybox.position.x = 500;
            skybox.position.y = 0;
            skybox.position.z = -500;

            //---------- physics test ------------//
            var light = new THREE.AmbientLight( 0x404040 ); // soft white light
            light.intensity = 5;
            scene.add( light );

            this.geometry = new THREE.BoxGeometry(8000, 1000, 1000);
            this.material = new THREE.MeshPhongMaterial({transparent: true, opacity: 0});
            //this.material = new THREE.MeshPhongMaterial();

            //left
            //this.leftPhysicsMesh = new THREE.Mesh(this.geometry, this.material);
            this.leftPhysicsMesh = new physijs.Box( this.geometry, this.material, {mass: 2000, friction: 1});

            this.leftPhysicsMesh.position.x = 500;
            this.leftPhysicsMesh.position.y = 500;
            this.leftPhysicsMesh.position.z = 4000;
            scene.add(this.leftPhysicsMesh);

            //right
            //this.rightPhysicsMesh = new THREE.Mesh(this.geometry, this.material);
            this.rightPhysicsMesh = new physijs.Box( this.geometry, this.material, {mass: 2000, friction: 1});

            this.rightPhysicsMesh.position.x = 500;
            this.rightPhysicsMesh.position.y = 500;
            this.rightPhysicsMesh.position.z = -5000;
            scene.add(this.rightPhysicsMesh);


            //this.geometry = new THREE.BoxGeometry(8800, 1000, 400);
            //front
            //this.frontPhysicsMesh = new THREE.Mesh(this.geometry, this.material);
            this.frontPhysicsMesh = new physijs.Box( this.geometry, this.material, {mass: 2000, friction: 1});

            this.frontPhysicsMesh.position.x = -4000;
            this.frontPhysicsMesh.position.y = 500;
            this.frontPhysicsMesh.position.z = -500;
            this.frontPhysicsMesh.rotation.y = Math.PI/2;
            scene.add(this.frontPhysicsMesh);

            //front
            //this.backPhysicsMesh = new THREE.Mesh(this.geometry, this.material);
            this.backPhysicsMesh = new physijs.Box( this.geometry, this.material, {mass: 2000, friction: 1});

            this.backPhysicsMesh.position.x = 5000;
            this.backPhysicsMesh.position.y = 500;
            this.backPhysicsMesh.position.z = -500;
            this.backPhysicsMesh.rotation.y = Math.PI/2;
            scene.add(this.backPhysicsMesh);

            //---------- physics test ------------//

//            var moonLight = new THREE.DirectionalLight(0xc8bcbc);
//            moonLight.position.set( -4000, 4000, -4000 );
//            moonLight.castShadow = true;
//            moonLight.intensity = 0.1;
//            //moonLight.shadowDarkness = 0.5;
//            moonLight.shadowCameraVisible = true;
//            moonLight.shadow.mapSize.width = SHADOWMAPWIDTH;
//            moonLight.shadow.mapSize.height = SHADOWMAPHEIGHT;
//            moonLight.shadow.camera.near = 100;
//            moonLight.shadow.camera.far = 2048;
//            moonLight.shadow.camera.fov = 30;
//            skybox.add(moonLight);

//            var helper = new THREE.CameraHelper( moonLight.shadow.camera );
//             scene.add( helper );

            scene.add(skybox);
        }

        physicColision ( object ) {

            object.addEventListener(
                'physics.contactStart',
                function (event) {
                    vector = camera.getWorldDirection(vector);

                    console.log('collided at', event.relative_linear_velocity.length());

                    if (moveForward) {  //moving forward collisions

                        player.position.set(player.position.x - (100 * vector.x), player.position.y, player.position.z - (100 * vector.z));

                        controls.getObject().position.set(controls.getObject().position.x - (100 * vector.x), controls.getObject().position.y,
                            controls.getObject().position.z - (100 * vector.z));

                    } else if (moveBackward) {  //moving backwards collisions

                        player.position.set(player.position.x + (150 * vector.x), player.position.y, player.position.z + (150 * vector.z));

                        controls.getObject().position.set(controls.getObject().position.x + (150 * vector.x), controls.getObject().position.y,
                            controls.getObject().position.z + (150 * vector.z));

                    } else if (moveLeft) {//moving left collisions

                        if ((player.position.x + (100 * Math.cos(vector.x)) > 4450)){

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else if ((player.position.x - (100 * Math.cos(vector.x)) < -3450)) {

                            player.position.set(player.position.x + (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x + (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else if ((player.position.z + (100 * Math.cos(vector.z)) < 4450)) {

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z + (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else {

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z + (100 * Math.cos(vector.z)));

                        }


                    } else if (moveRight) { //moving right collisions

                        if ((player.position.x + (100 * Math.cos(vector.x)) > 4450)) {

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else if ((player.position.x - (100 * Math.cos(vector.x)) < -3450)) {

                            player.position.set(player.position.x + (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x + (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else if ((player.position.z + (100 * Math.cos(vector.z)) > 3450)) {

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z + (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z - (100 * Math.cos(vector.z)));

                        } else {

                            player.position.set(player.position.x - (100 * Math.cos(vector.x)), player.position.y, player.position.z - (100 * Math.cos(vector.z)));

                            controls.getObject().position.set(controls.getObject().position.x - (100 * Math.cos(vector.x)), controls.getObject().position.y,
                                controls.getObject().position.z + (100 * Math.cos(vector.z)));
                        }

                    } else {
                        player.position.set(player.position.x - (100 * vector.x), player.position.y, player.position.z - (100 * vector.z));

                        controls.getObject().position.set(controls.getObject().position.x - (100 * vector.x), controls.getObject().position.y,
                            controls.getObject().position.z - (100 * vector.z));
                    }

                    playerProfile.hit = 1;

                    for ( var i in keys ) {

                        if ( (((controls.getObject().position.x + 300) > keys[i].position.x) && ((controls.getObject().position.x - 300) < keys[i].position.x)) &&
                            (((controls.getObject().position.z + 300) > keys[i].position.z) && ((controls.getObject().position.z - 300) < keys[i].position.z)) ) {


                            playerProfile.objectives += 1;
                            document.getElementById('objects').innerHTML = playerProfile.objectives  + "/" + toFind;

                            console.log("works");
                            delete keys[i];

                            playerProfile.hit = 0;

                            if(playerProfile.objectives === 5) {
                                isRunning = false;
                                controls.enabled = false;
                                gameState.style.display = 'block';
                                conditionWin.style.display = 'block';
                            }
                        }
                    }

                }
            );

            object.addEventListener(
                'physics.contactContinue',
                function (event) {
                    console.log('continued at', event.relative_linear_velocity.length());
                }
            );

            object.addEventListener(
                'physics.contactEnd',
                function (event) {
                    if (playerProfile.hit) {
                        playerProfile.setUpdate(1);
                        playerProfile.hit = 0;
                    }
                    console.log('ended at', event.relative_linear_velocity.length());
                }
            );

        }

    }

    let app = new Aplication(); // instancia nova aplicação

    /**
     * Lista de objectos da cena
     * @type {[*]}
     */
    let objs = [
        new Floor({width: 8000, height: 8000},{x:500,y:0,z:-500}),
        new Monster(),
        new InformationPlate({width: 30, height: 550, depth:10},{x:-1300,y:0,z:10}),

        // Path
//        new Tree({x:300,y:0,z:-200}, 1),new Tree({x:300,y:0,z:200}, 1),
//        new Tree({x:1000,y:0,z:-200}, 2),new Tree({x:1000,y:0,z:200}, 2),
//        new Tree({x:2000,y:0,z:-200}, 3),new Tree({x:2000,y:0,z:200}, 3),
//        new Tree({x:3000,y:0,z:-200}, 2),
//        new Tree({x:3000,y:0,z:200}, 4),
//        new Tree({x:4000,y:0,z:-200}, 1),new Tree({x:3700,y:0,z:325}, 2),
//        new Tree({x:2652,y:0,z:-400}, 3),new Tree({x:2500,y:0,z:700}, 3),
//        new Tree({x:1500,y:0,z:-485}, 3),new Tree({x:1500,y:0,z:700}, 3),
//        new Tree({x:3500,y:0,z:-200}, 3),new Tree({x:3250,y:0,z:300}, 3),
//        new Tree({x:800,y:0,z:-400}, 3),new Tree({x:800,y:0,z:500}, 3),
//        new Tree({x:200,y:0,z:-485}, 3),new Tree({x:200,y:0,z:725}, 3),
//        new Tree({x:-200,y:0,z:-400}, 3),new Tree({x:-200,y:0,z:600}, 3),
//        new Rocks({x:-200,y:0,z:-200}), new Rocks({x:200,y:0,z:200}),
//        new Rocks({x:-800,y:0,z:-200}), new Rocks({x:800,y:0,z:200}),
//        new Rocks({x:-1000,y:0,z:-300}), new Rocks({x:1000,y:0,z:200}),
//        new RockStack({x:55,y:0,z:-1778}, 2),new RockStack({x:1000,y:0,z:1000}, 3),
//        new RockStack({x:2000,y:0,z:-2455}, 3),new RockStack({x:3000,y:0,z:2856}, 4),
//        new Path({x:149,y:0,z:10}, 1, 'S'),new Path({x:661,y:0,z:10}, 1, 'S'),
//        new Path({x:1173,y:0,z:10}, 1, 'S'),new Path({x:1685,y:0,z:10}, 1, 'S'),
//        new Path({x:2197,y:0,z:10}, 1, 'S'),new Path({x:2709,y:0,z:10}, 1, 'S'),
//        new Path({x:3221,y:0,z:10}, 1, 'S'),new Path({x:3733,y:0,z:10}, 1, 'S'),
//        new Path({x:4245,y:0,z:10}, 1, 'S'),
//        new Tree({x:-600,y:0,z:-200}, 1),new Tree({x:-600,y:0,z:200}, 2),
//        new Tree({x:1300,y:0,z:-200}, 1),new Tree({x:1300,y:0,z:200}, 4),
//        new Tree({x:-150,y:0,z:-200}, 2),new Tree({x:-150,y:0,z:200}, 3),
        new LightPole({x:3500,y:0,z:200},{y:45},{intensity:0.5,angle:0.5},{intensity:3,angle:1.1}),
//        new LightPole({x:1550,y:0,z:-200},{y:30},{intensity:0.5,angle:0.5},{intensity:3,angle:1.1}),
//        new LightPole({x:0,y:0,z:200},{y:45},{intensity:0.5,angle:0.5},{intensity:3,angle:1}),

        // Desvio
        new Path({x:-363,y:0,z:10}, 1, 'S'),new Path({x:-1131,y:0,z:10}, 2, 'Y'),
        new Path({x:-1632.5,y:0,z:-569.5}, 3, 'S'), new Path({x:-1632.5,y:0,z:591.5}, 4, 'S'),
        new Tree({x:-1500,y:0,z:10}, 3),new Tree({x:-1200,y:0,z:-550}, 3),
        new Tree({x:-1970,y:0,z:-255}, 3),new Tree({x:-1950,y:0,z:275}, 3),
        new Tree({x:-2250,y:0,z:-150}, 3),new Tree({x:-2000,y:0,z:100}, 1),
        new LightPole({x:-1325,y:0,z:10},{y:0},{intensity:1,angle:0.5},{intensity:3,angle:1.1}),
        new Keys({x:-1600,y:0,z:20}),

        // cemiterio
        new Path({x:-2175,y:0,z:1135}, 6, 'L'),
        new Tree({x:-2500,y:0,z:1250}, 3),new Tree({x:-1500,y:0,z:1250}, 3),
        new Tree({x:-1000,y:0,z:500}, 1),new Tree({x:-1900,y:0,z:500}, 1),
        new Tree({x:-1500,y:0,z:3000},2),new Tree({x:-1900,y:0,z:500}, 1),
        new RockStack({x:-2200,y:0,z:1900},1),new RockStack({x:-2200,y:0,z:2200},1),
        new Keys({x:-2200,y:0,z:1920}),

//        new Tree({x:-1500,y:0,z:3000}, 1),new Tree({x:-1900,y:0,z:3000}, 3),
//        new Tree({x:-1000,y:0,z:3000}, 3),new Tree({x:-800,y:0,z:3000}, 4),
//        new Tree({x:-1000,y:0,z:1500}, 3),new Tree({x:-800,y:0,z:1700}, 4),
//        new Tree({x:-200,y:0,z:1500}, 1),new Tree({x:-150,y:0,z:1700}, 4),
//        new Tree({x:250,y:0,z:1250}, 3),new Tree({x:120,y:0,z:1174}, 1),
//        new Tree({x:350,y:0,z:1000}, 4),new Tree({x:420,y:0,z:945}, 1),
//        new Tree({x:650,y:0,z:1200}, 4),new Tree({x:720,y:0,z:1115}, 3),
//        new Tree({x:-1500,y:0,z:2500}, 1),new Tree({x:-1900,y:0,z:2500}, 2),
//        new Tree({x:-1000,y:0,z:1500}, 3),new Tree({x:-800,y:0,z:1500}, 4),
//        new Tree({x:-1000,y:0,z:3000}, 3),new Tree({x:-800,y:0,z:2500}, 4),
//        new Tree({x:-200,y:0,z:2250}, 1),new Tree({x:-150,y:0,z:500}, 4),
//        new Tree({x:250,y:0,z:3000}, 2),new Tree({x:120,y:0,z:1785}, 1),
//        new Tree({x:350,y:0,z:1621}, 4),new Tree({x:420,y:0,z:3574}, 1),
//        new Tree({x:650,y:0,z:2510}, 4),new Tree({x:720,y:0,z:500}, 2),
//        new Tree({x:1000,y:0,z:1500}, 3),new Tree({x:800,y:0,z:1500}, 1),
//        new Tree({x:1000,y:0,z:3000}, 3),new Tree({x:800,y:0,z:2500}, 1),
//        new Tree({x:2000,y:0,z:2250}, 1),new Tree({x:1800,y:0,z:500}, 3),
//        new Tree({x:2500,y:0,z:3000}, 3),new Tree({x:2800,y:0,z:1785}, 1),
//        new Tree({x:3000,y:0,z:1621},3),new Tree({x:3800,y:0,z:3574}, 1),
        new Tree({x:3500,y:0,z:2510}, 1),new Tree({x:4000,y:0,z:500}, 3),
        new Keys({x:4000,y:0,z:600}),
//        new Tree({x:3000,y:0,z:750}, 1),new Tree({x:3000,y:0,z:500}, 3),
//        new Tree({x:3250,y:0,z:1500}, 3),new Tree({x:3500,y:0,z:1785}, 1),
//        new Tree({x:3750,y:0,z:750},3),new Tree({x:3800,y:0,z:3574}, 1),
//        new Tree({x:4000,y:0,z:500}, 1),new Tree({x:4000,y:0,z:500}, 3),
        new Grave({x:-1550,y:0,z:1850}), new Grave({x:-1550,y:0,z:2150}),
        new LightPole({x:-1700,y:0,z:1450},{y:90},{intensity:0.5,angle:0.5},{intensity:3,angle:1}),

        // casa
//        new Path({x:-2175.5,y:0,z:-1112.5}, 5, 'R'),new Tree({x:-2500,y:0,z:-1250},3),
//        new Tree({x:-1500,y:0,z:-1250}, 1),new Tree({x:-1000,y:0,z:-500}, 1),
//        new Tree({x:4000,y:0,z:-1250}, 1),new Tree({x:4000,y:0,z:-500},1),
//        new Tree({x:3250,y:0,z:-750}, 3),new Tree({x:3250,y:0,z:-250}, 2),
//        new Tree({x:2500,y:0,z:-800}, 4),new Tree({x:2500,y:0,z:-300}, 1),
//        new Tree({x:1750,y:0,z:-600}, 1),new Tree({x:1750,y:0,z:-400}, 3),
//        new Tree({x:1000,y:0,z:-400}, 2),new Tree({x:1000,y:0,z:-700}, 1),
//        new Tree({x:250,y:0,z:-600}, 1),new Tree({x:250,y:0,z:-500}, 3),
//
//        new Tree({x:0,y:0,z:-1250}, 1),new Tree({x:-1250,y:0,z:-2500},1),
//        new Tree({x:750,y:0,z:-2500}, 3),new Tree({x:-500,y:0,z:-3000}, 4),
        new Tree({x:1500,y:0,z:-3000}, 4),new Tree({x:250,y:0,z:-3500}, 1),
        new Keys({x:1500,y:0,z:-3050}),
//        new Tree({x:2250,y:0,z:-2750}, 1),new Tree({x:1000,y:0,z:-2700}, 3),
//        new Tree({x:3000,y:0,z:-2500}, 3),new Tree({x:1750,y:0,z:-2200}, 1),
//        new Tree({x:3750,y:0,z:-1500}, 1),new Tree({x:2500,y:0,z:-2100}, 3),
//
//        new Tree({x:4000,y:0,z:-1500}, 1),new Tree({x:4000,y:0,z:-1200},1),
//        new Tree({x:3250,y:0,z:-1000}, 3),new Tree({x:3250,y:0,z:-3000}, 3),
//        new Tree({x:2500,y:0,z:-400}, 4),new Tree({x:2500,y:0,z:-3200}, 1),
//        new Tree({x:1750,y:0,z:-300}, 1),new Tree({x:1750,y:0,z:-1750}, 3),
//        new Tree({x:1000,y:0,z:-2000}, 3),new Tree({x:1000,y:0,z:-1000}, 1),
//        new Tree({x:250,y:0,z:-1700}, 1),new Tree({x:250,y:0,z:-1000}, 3),
        new House ({x:-2150,y:0,z:-2500}), new Keys({x:-1975,y:0,z:-2065}),
//        new LightPole({x:-2300,y:0,z:-2000},{y:0},{intensity:1,angle:0.5},{intensity:3,angle:1})
    ];

    /**
     * Metodo que adiciona a lista de objectos a cena
     */
    app.add(objs);

</script>

</body>
</html>