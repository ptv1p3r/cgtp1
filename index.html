<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <!--<link rel="stylesheet" href="css/world@war.css">-->
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>

<script src="js/three.js"></script>
<script src="js/date.format.js"></script>
<script src="js/OrbitControls.js"></script>

<script>
    var gameDiv = document.getElementById('gameDiv');
    var myCanvas = document.getElementById('myCanvas');

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        DISTANCIA_MAX = 1000,
        DISTANCIA_MIN = 0;

    var scene, renderer, camera, controls, cloudMesh, floorMesh, material;

    class Obj{
        constructor(){}
    }

    class Cube extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            this.material = new THREE.MeshBasicMaterial();
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
        }

        update(){
            this.mesh.rotation.x += 0.1;
            this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Aplication{
        constructor() {
            this.objects = [];

            this.createScene();
        }

        createScene() {
            //SCENE
            scene = new THREE.Scene();

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.z = 1.8;
            //camera.lookAt(scene.position);


            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL
            controls = new THREE.OrbitControls(camera);

            //controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.maxDistance = DISTANCIA_MAX;
            controls.minDistance = DISTANCIA_MIN;

            //LIGHTS
            var light = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(light);

            createFloor();

            window.addEventListener( 'resize', onWindowResize, false );

            document.addEventListener('keydown', keyboard, false);

            this.render();
        }

        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            renderer.render(scene, camera);
        }

        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

    }

    let app = new Aplication();

    let objs = [
        new Cube({with: 4, height: 5, depth:10},{x:5,y:4,z:-2})
    ];
    app.add(objs);

    function keyboard() {

        var speed = 10;

        if (event.keyCode == 87) {
            camera.position.x += speed;

        } else if (event.keyCode == 83) {
            camera.position.x -= speed;
        }
    }

    function createFloor() {
        var geometry = new THREE.PlaneGeometry(1000,1000);

        scene.fog = new THREE.FogExp2( 0xefd1b5, 0.0025 );

        //var material = new THREE.MeshLambertMaterial({color: 0xF3FFE2});
        material = new THREE.MeshBasicMaterial();
        material.map = THREE.ImageUtils.loadTexture('images/earthmap4k.jpg');            // Diffuse Texture

        material.bumpMap = THREE.ImageUtils.loadTexture('images/earthbump4k.jpg');       // Bump Texture
        material.bumpScale = 0.05;
        material.specularMap = THREE.ImageUtils.loadTexture('images/earthspec4k.jpg');   // Spectacular Texture
        material.specular = new THREE.Color('grey');


        floorMesh = new THREE.Mesh(geometry, material);

        floorMesh.position.x = 500;
        floorMesh.position.y = -1.8;
        floorMesh.position.z = -500;


        floorMesh.rotation.x = -Math.PI/2;  // deita a mesh

        scene.add(floorMesh);
    }

    function createEarthClouds() {
        var geometry1   = new THREE.SphereGeometry(177, 32, 32);
        var material1  = new THREE.MeshPhongMaterial({
            map         : new THREE.ImageUtils.loadTexture('images/earthcloudmap2.jpg'),
            side        : THREE.DoubleSide,
            opacity     : 0.3,
            transparent : true,
            depthWrite  : false
        });
        cloudMesh = new THREE.Mesh(geometry1, material1);
        earthMesh.add(cloudMesh);
    }

    function createSkyBox() {
        // SKYBOX
        var geometry2  = new THREE.SphereGeometry(1000, 32, 32);
        var material2  = new THREE.MeshBasicMaterial({
            map   : new THREE.ImageUtils.loadTexture('images/skybox1.jpg'),
            side  : THREE.BackSide
        });
        var skyBoxMesh  = new THREE.Mesh(geometry2, material2); // cria mesh com geometria e material
        scene.add(skyBoxMesh);
    }

    /**
     * Metodo que controla o redimensionamento da janela do browser
     */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        render();
    }

</script>
</body>
</html>