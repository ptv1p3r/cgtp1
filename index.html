<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computação Gráfica ISMAT 2017 TP1</title>
    <!--<link rel="stylesheet" href="css/world@war.css">-->
</head>
<body>

<canvas id ="myCanvas" style="display: block"></canvas>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>

<script>
    var gameDiv = document.getElementById('gameDiv');
    var myCanvas = document.getElementById('myCanvas');

    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000,
        DISTANCIA_MAX = 1000,
        DISTANCIA_MIN = 0;

    var scene, renderer, camera, controls, material;

    class Obj{
        constructor(){}
    }

    class Tree extends Obj{
        constructor(position){
            super();

            var loader = new THREE.ObjectLoader();
            loader.load("models/coconut-tree.json", function ( obj ) {
                obj.position.x = position.x;
                obj.position.y = position.y;
                obj.position.z = position.z;
                scene.add( obj );
            });
        }

        update(){
//            this.mesh.rotation.x += 0.1;
//            this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Cube extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
            this.material = new THREE.MeshBasicMaterial();
            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
        }

        update(){
            this.mesh.rotation.x += 0.1;
            this.mesh.rotation.y += 0.1;
        }

        getMesh(){
            return this.mesh;
        }
    }

    class Floor extends Obj{
        constructor(size,position){
            super();
            this.geometry = new THREE.PlaneGeometry(size.width,size.height);
            this.material = new THREE.MeshBasicMaterial();

            this.material.map = THREE.ImageUtils.loadTexture('images/terrain1.jpg');            // Diffuse Texture
//            this.material.bumpMap = THREE.ImageUtils.loadTexture('images/earthmap4k.jpg');       // Bump Texture
//            this.material.bumpScale = 0.05;
//            this.material.specularMap = THREE.ImageUtils.loadTexture('images/earthspec4k.jpg');   // Spectacular Texture
//            this.material.specular = new THREE.Color('grey');

            this.mesh = new THREE.Mesh(this.geometry, this.material);

            this.mesh.position.x = position.x;
            this.mesh.position.y = position.y;
            this.mesh.position.z = position.z;
            this.mesh.rotation.x = -Math.PI/2;
        }


        getMesh(){
            return this.mesh;
        }
    }

    class Aplication{
        constructor() {
            this.objects = [];

            this.createScene();
        }

        createScene() {
            //SCENE
            scene = new THREE.Scene();

            //CAMERA
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.z = 1.8;
            //camera.lookAt(scene.position);


            //RENDERER
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
            renderer.setClearColor(0x000000);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            //CAMERA CONTROL
            controls = new THREE.OrbitControls(camera);

            //controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.maxDistance = DISTANCIA_MAX;
            controls.minDistance = DISTANCIA_MIN;

            //LIGHTS
            var light = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(light);

            window.addEventListener( 'resize', this.onWindowResize, false );

            document.addEventListener('keydown', this.onKeyboardPress, false);

            this.render();
        }

        onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            this.render();
        }

        onKeyboardPress() {

            var speed = 2;

            if(event.keyCode === 87){ // W key
                camera.position.x += -Math.sin(camera.rotation.y) * speed;
                camera.position.z += -Math.cos(camera.rotation.y) * speed;
            }

            if(event.keyCode === 83){ // S key
                camera.position.x += Math.sin(camera.rotation.y) * speed;
                camera.position.z += Math.cos(camera.rotation.y) * speed;
            }


            if(event.keyCode === 65){ // A key
                camera.position.x += Math.sin(camera.rotation.y - Math.PI/2) * speed;
                camera.position.z += Math.cos(camera.rotation.y - Math.PI/2) * speed;
            }

            if(event.keyCode === 68){ // D key
                camera.position.x += -Math.sin(camera.rotation.y - Math.PI/2) * speed;
                camera.position.z += -Math.cos(camera.rotation.y - Math.PI/2) * speed;
            }

            //TEMP KEYS PARA RODAR A CAMERA
            if(event.keyCode === 81){ // Q key
                camera.rotation.y += Math.PI*speed/100;
            }

            if(event.keyCode === 69){ // E key
                camera.rotation.y -= Math.PI*speed/100;
            }

            renderer.render(scene, camera);
        }

        render(){
            requestAnimationFrame(() => {
                this.render();
            });

            renderer.render(scene, camera);
        }

        add(mesh) {
            if (Array.isArray(mesh)) {
                for (var index in mesh) {
                    this.objects.push(mesh[index]);
                    scene.add(mesh[index].getMesh());
                }
            } else {
                this.objects.push(mesh);
                scene.add(mesh.getMesh());
            }
        }

    }

    let app = new Aplication();

    let objs = [
        new Floor({width: 1000, height: 1000}, {x:0,y:-1.8,z:0}),
        new Cube({width: 4, height: 5, depth:10}, {x:5,y:4,z:-2}),
        new Tree({x:2225,y:4,z:-2})
    ];
    app.add(objs);

</script>
</body>
</html>